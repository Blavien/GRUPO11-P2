Index: src/main/java/Client.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.crypto.SecretKey;\r\nimport java.io.*;\r\nimport java.math.BigInteger;\r\nimport java.net.Socket;\r\nimport java.nio.file.Files;\r\nimport java.security.KeyPair;\r\nimport java.util.ArrayList;\r\nimport java.util.Scanner;\r\nimport java.security.KeyPair;\r\nimport java.security.PrivateKey;\r\nimport java.security.PublicKey;\r\n\r\n/**\r\n * This class represents the client. The client sends the messages to the server by means of a socket. The use of Object\r\n * streams enables the sender to send any kind of object.\r\n */\r\npublic class Client {\r\n    private static final String HOST = \"0.0.0.0\";\r\n    private final Socket client;\r\n    private final ObjectInputStream in;\r\n    private final ObjectOutputStream out;\r\n    private boolean isConnected;\r\n    private String client_name;\r\n    private PrivateKey privateKey;\r\n    private PublicKey publicKey;\r\n    private SecretKey macKey;\r\n    private int requestLimit;\r\n    private String fileName;\r\n    private PublicKey serverPublicRSAKey;\r\n    private static final Scanner scan = new Scanner(System.in);\r\n    private BigInteger sharedSecret;\r\n    private ArrayList<Integer> choice;       // get(0) - Hashing algorithm       get(1) - Encryption algorithm\r\n                                                                        //    0 - MAC    1 - Hash                   0 - AES   1 -\r\n    /**\r\n     * Constructs a Client object by specifying the port to connect to. The socket must be created before the sender can\r\n     * send a message.\r\n     *\r\n     * @param port the port to connect to\r\n     * @throws IOException when an I/O error occurs when creating the socket\r\n     */\r\n    public Client(int port) throws Exception {\r\n        this.requestLimit = 0;\r\n\r\n        client = new Socket ( HOST , port );\r\n\r\n        out = new ObjectOutputStream ( client.getOutputStream ( ) );\r\n\r\n        in = new ObjectInputStream ( client.getInputStream ( ) );\r\n\r\n        isConnected = true; // TODO: Check if this is necessary or if it should be controlled\r\n\r\n        // Create a temporary directory for putting the request files\r\n\r\n        //userDir = Files.createTempDirectory ( \"fileServer\" ).toFile ( ).getAbsolutePath ( );\r\n\r\n        System.out.println(\"\\nInsert your username\");\r\n        String name = scan.next();\r\n        this.client_name = name;\r\n\r\n        RSA.storeRSAKeys ( RSA.generateKeyPair() , client_name);\r\n\r\n        this.setPrivateKey();\r\n        this.setPublicKey();\r\n\r\n\r\n    }\r\n    public String getClientName() {\r\n        return client_name;\r\n    }\r\n    public void setClientName(String client_name){\r\n        this.client_name = client_name;\r\n    }\r\n    public void setPrivateKey() throws Exception{ this.privateKey = RSA.getPrivateKey(this.client_name); }\r\n    public void setPublicKey() throws Exception{ this.publicKey = RSA.getPublicKey(this.client_name); }\r\n    public PrivateKey getPrivateKey() throws Exception{ return this.privateKey; }\r\n    public PublicKey getPublicKey() throws Exception{ return RSA.getPublicKey(this.client_name); }\r\n    public void setFileName(String request){\r\n        this.fileName = request;\r\n    }\r\n\r\n    public String getFileName() {\r\n        return this.fileName;\r\n    }\r\n\r\n    public void setConnected(boolean bool) {\r\n        this.isConnected = bool;\r\n    }\r\n\r\n    public boolean doHandshake() throws Exception {\r\n        boolean handshakeInsuccess = false;\r\n        boolean invalid_choice_hashing = false;\r\n        boolean invalid_choice_encryption = false;\r\n        choice = new ArrayList<Integer>(); //Array novo sempre que isto é chamado\r\n\r\n        System.out.println(\"\\nWe will make you set up your commmunication and security, cause I want 20.\");\r\n\r\n        // choice.get(0)\r\n        System.out.println(\"\\nHashing algoritm:\");\r\n        System.out.println(\"0. MAC\");\r\n        System.out.println(\"1. Hash of 512 bits (SHA - 512)\");\r\n        System.out.println(\"2. 2048 eggs & bacon\");\r\n        System.out.println(\"3. CBC\");\r\n        int i = scan.nextInt();\r\n        switch (i){\r\n            case 0:\r\n                choice.add(0); // [0] = 0\r\n                break;\r\n            case 1:\r\n                choice.add(1); // [0] = 1\r\n                break;\r\n            case 2:\r\n                invalid_choice_hashing = true;\r\n                break;\r\n            case 3:\r\n                invalid_choice_hashing = true;\r\n                break;\r\n        }\r\n        // choice.get(1)\r\n        System.out.println(\"\\nEncryption/Decryption algoritm:\");\r\n        System.out.println(\"0. AES\");\r\n        System.out.println(\"1. DES\");\r\n        System.out.println(\"2. 360-no-scope-DES\");\r\n        System.out.println(\"3. CBC\");\r\n        i = scan.nextInt();\r\n        switch (i){\r\n            case 0:\r\n                choice.add(0); // [1] = 0\r\n                break;\r\n            case 1:\r\n                choice.add(1); // [1] = 1\r\n                break;\r\n            case 2:\r\n                invalid_choice_encryption = true;\r\n                break;\r\n            case 3:\r\n                invalid_choice_encryption = true;\r\n                break;\r\n        }\r\n\r\n        //Faz o handshake\r\n        if(invalid_choice_hashing == false && invalid_choice_encryption == false){\r\n            serverPublicRSAKey = rsaKeyDistribution();\r\n            sharedSecret = agreeOnSharedSecret ( serverPublicRSAKey );\r\n\r\n            macKey=MAC.createMACKey();\r\n            System.out.println(choice);\r\n            sendClientChoice();\r\n\r\n            if(choice.get(0) == 0){\r\n                sendMacKey();\r\n            }\r\n        }else{\r\n            handshakeInsuccess = true;\r\n            System.out.println(\"This server doesn't support those algorithms.\");\r\n        }\r\n        return handshakeInsuccess;\r\n    }\r\n    public void sendClientChoice() throws IOException {\r\n        out.writeObject(choice);\r\n        out.flush ();\r\n    }\r\n    public void endConnection() throws Exception {\r\n        this.closeConnection();\r\n    }\r\n\r\n    /**\r\n     * Reads the response from the server and writes the file to the temporary directory.\r\n     *\r\n     * @param fileName the name of the file to write\r\n     */\r\n    private void processResponse(String fileName) throws Exception {\r\n        String unitedMessage = \"\";\r\n\r\n        //BigInteger sharedSecret = agreeOnSharedSecret(serverPublicRSAKey);\r\n\r\n        Message response = (Message) in.readObject();\r\n        byte[] decryptedFile = null;\r\n        //CRYPTO\r\n        if(choice.get(1) == 0) {\r\n            decryptedFile = AES.decrypt(response.getMessage(), sharedSecret.toByteArray());\r\n        }else if(choice.get(1) == 1){\r\n            decryptedFile = DES.decrypt(response.getMessage(), sharedSecret.toByteArray());\r\n\r\n        }\r\n        //HASHING\r\n        byte[] computedDigest = null;\r\n        if(choice.get(0) == 0) {\r\n            computedDigest = MAC.generateMAC(decryptedFile, macKey);\r\n            if (!MAC.verifyMAC(response.getSignature(), computedDigest)) {\r\n                throw new RuntimeException(\"The integrity of the message is not verified\");\r\n            }\r\n        }else if(choice.get(0) == 1){\r\n            computedDigest = Hash.generateDigest(decryptedFile);\r\n            if (!Hash.verifyDigest(response.getSignature(), computedDigest)) {\r\n                throw new RuntimeException(\"The integrity of the message is not verified\");\r\n            }\r\n        }\r\n\r\n        String decryptedContent = new String(decryptedFile);  // To handle divided content\r\n\r\n        if (decryptedContent.equals(\"INICIO\")) { //Decrypts this first message - INICIO\r\n\r\n            //System.out.println(\"Recebeu o inicio\");\r\n\r\n            while (!decryptedContent.equals(\"FIM\")){ //Decrypts the rest of the message until we get the last message - FIM\r\n\r\n                response = (Message) in.readObject();\r\n                //CRYPTO\r\n                if(choice.get(1) == 0) {\r\n                    decryptedFile = AES.decrypt(response.getMessage(), sharedSecret.toByteArray());\r\n                }else if(choice.get(1) == 1){\r\n                    decryptedFile = DES.decrypt(response.getMessage(), sharedSecret.toByteArray());\r\n\r\n                }\r\n                //HASHING\r\n                if(choice.get(0) == 0) {\r\n                    computedDigest = MAC.generateMAC(decryptedFile, macKey);\r\n                    if (!MAC.verifyMAC(response.getSignature(), computedDigest)) {\r\n                        throw new RuntimeException(\"The integrity of the message is not verified\");\r\n                    }\r\n                }else if(choice.get(0) == 1){\r\n                    computedDigest = Hash.generateDigest(decryptedFile);\r\n                    if (!Hash.verifyDigest(response.getSignature(), computedDigest)) {\r\n                        throw new RuntimeException(\"The integrity of the message is not verified\");\r\n                    }\r\n                }\r\n\r\n                decryptedContent = new String(decryptedFile);\r\n\r\n                unitedMessage +=new String(decryptedFile);\r\n            }\r\n            System.out.println(\"We have reached the end of the file content.\");\r\n\r\n            System.out.println(\"This is the file content:\");\r\n\r\n            System.out.println(new String (unitedMessage));\r\n\r\n            saveFiles(unitedMessage);\r\n\r\n        }else{\r\n            saveFiles(new String(decryptedFile));\r\n        }\r\n    }\r\n\r\n    public void saveFiles(String decryptedFile) throws Exception{\r\n        //Criação da pasta que receberá os ficheiros\r\n        String privateClientPath = this.client_name + \"/files\";\r\n        File privateClientFolder = new File(privateClientPath);\r\n        privateClientFolder.mkdirs();\r\n\r\n        //Criação do ficheiro de texto que receberá o conteúdo do ficheiro de texto pedido e a escrita do mesmo\r\n        String decryptedFileString = decryptedFile;\r\n        File arquivo = new File(this.client_name + \"/files/User_\" + this.getFileName());\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(arquivo));\r\n        bw.write(decryptedFileString);\r\n        bw.close();\r\n    }\r\n    /**\r\n     * Closes the connection by closing the socket and the streams.\r\n     */\r\n    private void closeConnection ( ) {\r\n        try {\r\n            client.close ( );\r\n            out.close ( );\r\n            in.close ( );\r\n        } catch ( IOException e ) {\r\n            throw new RuntimeException ( e );\r\n        }\r\n    }\r\n\r\n    private void sendPublicDHKey ( byte[] publicKey ) throws Exception {\r\n        out.writeObject ( publicKey );\r\n    }\r\n\r\n    private PublicKey rsaKeyDistribution ( ) throws Exception {\r\n        // Sends the public key\r\n        sendPublicRSAKey ( );\r\n        // Receive the public key of the sender\r\n        return ( PublicKey ) in.readObject ( );\r\n    }\r\n\r\n    private void sendPublicRSAKey ( ) throws IOException {\r\n        out.writeObject ( publicKey );\r\n        out.flush ( );\r\n    }\r\n    private void sendMacKey() throws Exception{\r\n        out.writeObject(macKey);\r\n        out.flush ();\r\n    }\r\n    public void sendMessage ( String message ) throws Exception {\r\n        // Agree on a shared secret\r\n        // BigInteger sharedSecret = agreeOnSharedSecret ( serverPublicRSAKey );\r\n        // Encrypts the message\r\n        byte[] encryptedMessage = null;\r\n        if(choice.get(1) == 0){ //AES\r\n            encryptedMessage = AES.encrypt ( message.getBytes ( ) , sharedSecret.toByteArray ( ) );\r\n        }\r\n        if(choice.get(1) == 1){ //DES\r\n            encryptedMessage = DES.encrypt ( message.getBytes ( ) , sharedSecret.toByteArray ( ) );\r\n        }\r\n        byte[] digest = null;\r\n\r\n        if(choice.get(0) == 0){ //MAC\r\n            // Generates the MAC\r\n            digest = MAC.generateMAC(message.getBytes ( ),macKey);\r\n        }else if(choice.get(0) == 1){ //HASH\r\n            digest = Hash.generateDigest(message.getBytes ( ));\r\n        }\r\n        // Creates the message object\r\n        Message messageObj = new Message ( encryptedMessage , digest );\r\n        // Sends the encrypted message\r\n        out.writeObject ( messageObj );\r\n        out.flush();\r\n    }\r\n    private BigInteger agreeOnSharedSecret (PublicKey serverPublicRSAKey ) throws Exception {\r\n        // Generates a private key\r\n        BigInteger privateDHKey = DiffieHellman.generatePrivateKey ( );\r\n        BigInteger publicDHKey = DiffieHellman.generatePublicKey ( privateDHKey );\r\n        // Sends the public key to the server encrypted\r\n        sendPublicDHKey ( RSA.encryptRSA ( publicDHKey.toByteArray ( ) , privateKey ) );\r\n        // Waits for the server to send his public key\r\n        BigInteger serverPublicKey = new BigInteger ( RSA.decryptRSA ( ( byte[] ) in.readObject ( ) , serverPublicRSAKey ) );\r\n        // Generates the shared secret\r\n        return DiffieHellman.computePrivateKey ( serverPublicKey , privateDHKey );\r\n    }\r\n\r\n    /**\r\n     * Executes the client. It reads the file from the console and sends it to the server. It waits for the response and\r\n     * writes the file to the temporary directory.\r\n     */\r\n    public void execute() throws Exception{\r\n        Scanner usrInput = new Scanner ( System.in );\r\n        if( isConnected ) {\r\n            // Reads the message to extract the path of the file\r\n            System.out.println ( \"Write the path of the file\" );\r\n            String request = \"USERNAME: \"+this.client_name+ \": \"+usrInput.nextLine ( );\r\n            this.setFileName(RequestUtils.splitRequest(request).get(1));\r\n            // Request the file\r\n            sendMessage ( request );\r\n            // Waits for the response\r\n            processResponse ( RequestUtils.getFileNameFromRequest ( request ) );\r\n        }\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Client.java b/src/main/java/Client.java
--- a/src/main/java/Client.java	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ b/src/main/java/Client.java	(date 1683563461728)
@@ -119,8 +119,8 @@
         System.out.println("\nEncryption/Decryption algoritm:");
         System.out.println("0. AES");
         System.out.println("1. DES");
-        System.out.println("2. 360-no-scope-DES");
-        System.out.println("3. CBC");
+        System.out.println("2. 3DES");
+        System.out.println("3. 360-no-scope-DES");
         i = scan.nextInt();
         switch (i){
             case 0:
@@ -130,7 +130,7 @@
                 choice.add(1); // [1] = 1
                 break;
             case 2:
-                invalid_choice_encryption = true;
+                choice.add(2); // [1] = 2
                 break;
             case 3:
                 invalid_choice_encryption = true;
@@ -178,9 +178,12 @@
         //CRYPTO
         if(choice.get(1) == 0) {
             decryptedFile = AES.decrypt(response.getMessage(), sharedSecret.toByteArray());
-        }else if(choice.get(1) == 1){
+        }
+        if(choice.get(1) == 1){
             decryptedFile = DES.decrypt(response.getMessage(), sharedSecret.toByteArray());
-
+        }
+        if(choice.get(1) == 2){
+            decryptedFile = DES3.decrypt(response.getMessage(), sharedSecret.toByteArray());
         }
         //HASHING
         byte[] computedDigest = null;
@@ -208,9 +211,12 @@
                 //CRYPTO
                 if(choice.get(1) == 0) {
                     decryptedFile = AES.decrypt(response.getMessage(), sharedSecret.toByteArray());
-                }else if(choice.get(1) == 1){
+                }
+                if(choice.get(1) == 1){
                     decryptedFile = DES.decrypt(response.getMessage(), sharedSecret.toByteArray());
-
+                }
+                if(choice.get(1) == 2){
+                    decryptedFile = DES3.decrypt(response.getMessage(), sharedSecret.toByteArray());
                 }
                 //HASHING
                 if(choice.get(0) == 0) {
@@ -298,6 +304,10 @@
         if(choice.get(1) == 1){ //DES
             encryptedMessage = DES.encrypt ( message.getBytes ( ) , sharedSecret.toByteArray ( ) );
         }
+        if(choice.get(1) == 2){
+            encryptedMessage = DES3.encrypt(message.getBytes(), sharedSecret.toByteArray());
+        }
+
         byte[] digest = null;
 
         if(choice.get(0) == 0){ //MAC
Index: src/main/java/ClientHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.crypto.SecretKey;\r\nimport java.io.IOException;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.math.BigInteger;\r\nimport java.net.Socket;\r\nimport java.security.PublicKey;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * This class represents the client handler. It handles the communication with the client. It reads the file from the\r\n * server and sends it to the client.\r\n */\r\npublic class ClientHandler extends Thread {\r\n    private final ObjectInputStream in;\r\n    private final ObjectOutputStream out;\r\n    private final Socket client;\r\n    private ArrayList<String> requestSplit;\r\n    private SecretKey clientMACKey;\r\n    private ArrayList<Integer> clientChoice;\r\n\r\n    /**\r\n     * Creates a ClientHandler object by specifying the socket to communicate with the client. All the processing is\r\n     * done in a separate thread.\r\n     *\r\n     * @throws IOException when an I/O error occurs when creating the socket\r\n     */\r\n    public ClientHandler (Socket client) throws Exception {\r\n        this.client = client;\r\n        in = new ObjectInputStream ( this.client.getInputStream ( ) );\r\n        out = new ObjectOutputStream ( this.client.getOutputStream ( ) );\r\n        boolean isConnected = true; // TODO: Check if this is necessary or if it should be controlled\r\n    }\r\n\r\n    @Override\r\n    public void run ( ) {\r\n        super.run ( );\r\n        try {\r\n            sleep(2000);\r\n            PublicKey clientPublicRSAKey;\r\n\r\n            while(RequestUtils.readNumberFromFile(RequestUtils.HANDSHAKE_SIGNAL) != 1){  }\r\n\r\n            clientPublicRSAKey = rsaKeyDistribution ( in );\r\n            BigInteger sharedSecret = agreeOnSharedSecret ( clientPublicRSAKey );\r\n            System.out.println(\"SERVER : Handshake was a sucess.\");\r\n\r\n\r\n            clientChoice = receiveClientChoice();\r\n            System.out.print(\"SERVER : Client setup \");\r\n            printClientChoice(clientChoice);\r\n\r\n            if(clientChoice.get(0) == 0){\r\n                clientMACKey = receiveMacKey();\r\n                System.out.println(\"SERVER : MACK Key received.\");\r\n            }\r\n\r\n            int i = 0;\r\n            while ( i != 5) {\r\n\r\n                byte[] message = process ( in , sharedSecret.toByteArray ( ), clientChoice );\r\n\r\n                if(message != null ){\r\n                    System.out.println(\"\\n***** REQUEST *****\\n\"+ new String(message));\r\n\r\n                    //Splits message received\r\n\r\n                    requestSplit = RequestUtils.splitRequest(new String(message));\r\n\r\n                    //Regista os número de pedidos feitos por este utilizador\r\n\r\n                    RequestUtils.registerRequests (requestSplit);\r\n\r\n                    // Reads the file and sends it to the client\r\n\r\n                    byte[] content = FileHandler.readFile ( RequestUtils.getAbsoluteFilePath ( requestSplit.get(1) ) );\r\n\r\n                    String auxContent = new String(content);\r\n                    System.out.println(\"\\n***** FILE ********\\nHere's the file content: \");\r\n                    System.out.println(auxContent);\r\n\r\n                    int contentSize = content.length;\r\n                    //int numParts = (int) Math.ceil((double) contentSize / 2048);\r\n\r\n                    if(contentSize>2048) {\r\n\r\n                        sendFile(\"INICIO\".getBytes(), sharedSecret.toByteArray (), clientChoice);\r\n\r\n                        ArrayList<byte[]> contentDividido = ByteUtils.splitByteArray(auxContent.getBytes(),2048 );\r\n\r\n                        for (int j = 0; j < contentDividido.size(); j++) {\r\n\r\n                            sendFile(contentDividido.get(j), sharedSecret.toByteArray (), clientChoice);\r\n                            System.out.println(new String(contentDividido.get(j)));\r\n\r\n                        }\r\n                        sendFile(\"FIM\".getBytes(), sharedSecret.toByteArray (), clientChoice);\r\n                    }\r\n                    else {\r\n\r\n                        sendFile(content, sharedSecret.toByteArray (), clientChoice);\r\n\r\n                    }\r\n                    i = RequestUtils.requestLimit(requestSplit.get(0));\r\n\r\n                    //System.out.println(requestSplit.get(0)+\" - Request counter: \"+i);\r\n\r\n                }\r\n            }\r\n            if(i >= 5){\r\n\r\n                System.out.println(\"\\nClient \"+requestSplit.get(0) +\" exceeded the max requests.\");\r\n\r\n                RequestUtils.resetRequestCounter(requestSplit.get(0));\r\n\r\n                System.out.println(\"Client \"+requestSplit.get(0) +\" request counter has been reset to 0.\");\r\n            }\r\n\r\n            System.out.println(\"Closing socket connection.\");\r\n\r\n            closeConnection ( );\r\n        } catch ( IOException | ClassNotFoundException e ) {\r\n\r\n            closeConnection ( );\r\n\r\n        } catch (Exception e) {\r\n\r\n            throw new RuntimeException(e);\r\n\r\n        }\r\n    }\r\n    public void printClientChoice(ArrayList<Integer> clientChoice){\r\n        switch (clientChoice.get(0)) {\r\n            case 0:\r\n                System.out.print(\"[ MAC , \");\r\n                break;\r\n            case 1:\r\n                System.out.print(\"[ HASH , \");\r\n                break;\r\n        }\r\n        switch (clientChoice.get(1)) {\r\n            case 0:\r\n                System.out.print(\"AES ]\");\r\n                break;\r\n            case 1:\r\n                System.out.print(\"DES ]\");\r\n                break;\r\n        }\r\n        System.out.println(\"\\n\");\r\n    }\r\n    public static List<String> splitStringBySize(String input) {\r\n        List<String> output = new ArrayList<>();\r\n\r\n        // Verifica o tamanho da string em bytes\r\n        int inputSize = input.getBytes().length;\r\n\r\n        if (inputSize <= 2048) { // Se o tamanho for menor ou igual a 2KB, adiciona a string inteira na lista de saída\r\n            output.add(input);\r\n        } else { // Caso contrário, divide a string em pedaços de no máximo 2KB\r\n            int numParts = (int) Math.ceil((double) inputSize / 2048); // Calcula o número de pedaços necessários\r\n            int remainingBytes = inputSize;\r\n            int start = 0;\r\n            int end = 0;\r\n\r\n            for (int i = 0; i < numParts; i++) {\r\n                end += (remainingBytes > 2048) ? 2048 : remainingBytes; // Define o final do pedaço, garantindo que não ultrapasse 2KB\r\n                String part = input.substring(start, end); // Extrai o pedaço da string original\r\n                output.add(part); // Adiciona o pedaço na lista de saída\r\n                start = end;\r\n                remainingBytes = inputSize - end;\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n\r\n    /**\r\n     * Sends the file to the client\r\n     *\r\n     * @param content the content of the file to send\r\n     *\r\n     * @throws IOException when an I/O error occurs when sending the file\r\n     */\r\n    private void sendFile ( byte[] content , byte[] sharedSecret , ArrayList<Integer> choice) throws Exception {\r\n        byte[] encryptedResponse = null;\r\n\r\n        if(choice.get(1) == 0){ //AES\r\n            encryptedResponse = AES.encrypt ( content , sharedSecret );\r\n        }\r\n        if(choice.get(1) == 1){ //DES\r\n            encryptedResponse = DES.encrypt ( content , sharedSecret );\r\n        }\r\n        byte[] digest = null;\r\n\r\n        if(choice.get(0) == 0){ //MAC\r\n            // Generates the MAC\r\n            digest = MAC.generateMAC ( content, clientMACKey );\r\n        }else if(choice.get(0) == 1){ //HASH\r\n            digest = Hash.generateDigest(content);\r\n        }\r\n        // Creates the message object\r\n        Message responseObj = new Message ( encryptedResponse , digest );\r\n        // Sends the encrypted message\r\n        out.writeObject ( responseObj );\r\n        out.flush ( );\r\n    }\r\n\r\n    /**\r\n     * Closes the connection by closing the socket and the streams.\r\n     */\r\n    private void closeConnection ( ) {\r\n        try {\r\n            client.close ( );\r\n            out.close ( );\r\n            in.close ( );\r\n        } catch ( IOException e ) {\r\n            throw new RuntimeException ( e );\r\n        }\r\n    }\r\n    private SecretKey receiveMacKey() throws IOException, ClassNotFoundException {\r\n        SecretKey macKey = ( SecretKey ) in.readObject ( );\r\n        return macKey;\r\n    }\r\n    private ArrayList<Integer> receiveClientChoice () throws IOException, ClassNotFoundException {\r\n        ArrayList<Integer> choice = (ArrayList<Integer>) in.readObject();\r\n        return choice;\r\n    }\r\n    //DIFFIE HELLLMAN\r\n    private PublicKey rsaKeyDistribution (ObjectInputStream in ) throws Exception {\r\n        // Extract the public key\r\n        PublicKey senderPublicRSAKey = ( PublicKey ) in.readObject ( );\r\n        // Send the public key\r\n        sendPublicRSAKey ( );\r\n        return senderPublicRSAKey;\r\n    }\r\n    private void sendPublicRSAKey ( ) throws Exception {\r\n        out.writeObject ( Server.getPublicRSAKey());\r\n        out.flush ( );\r\n    }\r\n\r\n    private void sendPublicDHKey ( BigInteger publicKey ) throws Exception {\r\n        out.writeObject ( RSA.encryptRSA ( publicKey.toByteArray ( ) , Server.getPrivateRSAKey()));\r\n    }\r\n    /**\r\n     * Performs the Diffie-Hellman algorithm to agree on a shared private key.\r\n     *\r\n     * @param senderPublicRSAKey the public key of the sender\r\n     *\r\n     * @return the shared secret key\r\n     *\r\n     * @throws Exception when the key agreement protocol fails\r\n     */\r\n    private BigInteger agreeOnSharedSecret ( PublicKey senderPublicRSAKey ) throws Exception {\r\n        // Generate a pair of keys\r\n        BigInteger privateKey = DiffieHellman.generatePrivateKey ( );\r\n        BigInteger publicKey = DiffieHellman.generatePublicKey ( privateKey );\r\n        // Extracts the public key from the request\r\n        BigInteger clientPublicKey = new BigInteger ( RSA.decryptRSA ( ( byte[] ) in.readObject ( ) , senderPublicRSAKey ) );\r\n        // Send the public key to the client\r\n        sendPublicDHKey ( publicKey );\r\n        // Generates the shared secret\r\n        return DiffieHellman.computePrivateKey ( clientPublicKey , privateKey );\r\n    }\r\n\r\n    private byte[] process ( ObjectInputStream in , byte[] sharedSecret, ArrayList<Integer> clientChoice ) throws Exception {\r\n        // Reads the message object\r\n        Message messageObj = ( Message ) in.readObject ( );\r\n        // Extracts and decrypt the message\r\n        byte[] decryptedMessage = null;\r\n        if(clientChoice.get(1) == 0){\r\n            decryptedMessage = AES.decrypt ( messageObj.getMessage ( ) , sharedSecret );\r\n        }\r\n        if(clientChoice.get(1) == 1){\r\n            decryptedMessage = DES.decrypt ( messageObj.getMessage ( ) , sharedSecret );\r\n        }\r\n        // Computes the digest of the received message\r\n        byte[] computedDigest = null;\r\n        if(clientChoice.get(0) == 0){\r\n            computedDigest = MAC.generateMAC ( decryptedMessage, clientMACKey );\r\n            if ( ! MAC.verifyMAC ( messageObj.getSignature ( ) , computedDigest ) ) {\r\n                throw new RuntimeException ( \"The integrity of the message is not verified\" );\r\n            }\r\n        }\r\n        if (clientChoice.get(0) == 1){\r\n            //decryptedMessage = 3DES.decrypt ( messageObj.getMessage ( ) , sharedSecret );\r\n            computedDigest = Hash.generateDigest(decryptedMessage);\r\n            if ( ! Hash.verifyDigest ( messageObj.getSignature ( ) , computedDigest ) ) {\r\n                throw new RuntimeException ( \"The integrity of the message is not verified\" );\r\n            }\r\n        }\r\n        // Verifies the integrity of the message\r\n\r\n        return decryptedMessage;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ClientHandler.java b/src/main/java/ClientHandler.java
--- a/src/main/java/ClientHandler.java	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ b/src/main/java/ClientHandler.java	(date 1683563461734)
@@ -30,7 +30,6 @@
         this.client = client;
         in = new ObjectInputStream ( this.client.getInputStream ( ) );
         out = new ObjectOutputStream ( this.client.getOutputStream ( ) );
-        boolean isConnected = true; // TODO: Check if this is necessary or if it should be controlled
     }
 
     @Override
@@ -146,6 +145,9 @@
             case 1:
                 System.out.print("DES ]");
                 break;
+            case 2:
+                System.out.print("3DES ]");
+                break;
         }
         System.out.println("\n");
     }
@@ -192,6 +194,9 @@
         if(choice.get(1) == 1){ //DES
             encryptedResponse = DES.encrypt ( content , sharedSecret );
         }
+        if(choice.get(1) == 2){ //DES
+            encryptedResponse = DES3.encrypt ( content , sharedSecret );
+        }
         byte[] digest = null;
 
         if(choice.get(0) == 0){ //MAC
@@ -275,6 +280,9 @@
         if(clientChoice.get(1) == 1){
             decryptedMessage = DES.decrypt ( messageObj.getMessage ( ) , sharedSecret );
         }
+        if(clientChoice.get(1) == 2){
+            decryptedMessage = DES3.decrypt ( messageObj.getMessage ( ) , sharedSecret );
+        }
         // Computes the digest of the received message
         byte[] computedDigest = null;
         if(clientChoice.get(0) == 0){
Index: Re/private/privateKey.key
===================================================================
diff --git a/Re/private/privateKey.key b/Re/private/privateKey.key
deleted file mode 100644
--- a/Re/private/privateKey.key	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ /dev/null	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
@@ -1,11 +0,0 @@
-�� sr java.security.KeyRep��O����C L 	algorithmt Ljava/lang/String;[ encodedt [BL formatq ~ L typet Ljava/security/KeyRep$Type;xpt RSAur [B���T�  xp  �0�� 0
-	*�H��
- ��0�� � �E�DP{��vڴ2{�i~�=�'�ts[
-!�^�r�s3(0��a?a��H�Đ�X���cX}P�6w��d�����z7úWp 3|�� ~g��y(�2��5��,X���r9}JK�I��P��&��q���e��鎕��;��I3j	/��TaK���H��	�������s�*Đ �2k ?]v�t"z�l�6_,�T�u�&�
-��׺���o ����G��;�]2鱩�
-�Ѕ��� �l>Q0���lt�5i_I � |�Eˬ�/�Vf����V	�Q\!du�NV���.9�c��ᖍ�o؝$q���=^��G��8�9/7�-Xc�,4�h����I�>��3�2�ܱ����5yj���I�
-��ȷ�(�2��Ӣq���{�-��&т[P�j�4�%����؋�D�![r��;�k�.6Լ@��+Q�q!�D0m8��§� w��<�~
-�\��u�h� ӗ\0������NX�xՂU��C�.M}=���za�� �� >.�:�m�}����RA��+��wp*�YYV%�`�U�^�(����5�X'cY�5(����T�У:��0�������O\��]�*h
-�M!0yA�4�m�?mqEVۃ\��tH��Za�� �ʾ:\�����O�`������z��?���&���~�����Zmt�P8.1�G�׼�vw�ptG�ˈ9�I��?�U��d�(˯��2����[!B�_�9 IUל�Db��*N���`�v��UM�a�=��� �H�5�Ϣ��~�}�!J�:�Ģ�����ϛ�=�w^A%���4��X���­��o�*N��.�&�����w鸗�2,UX�\5PO�J��V�bƴ�i*ݟtj�3������Y����]�ח���z)����;(FwM,{~�Y�M�|�ʭ,��t�X�m;��g�A���^{o�g ���~���#%_�E-�2O��A�M��C�� ���T"�kA�˪q!?(�)
-�#974�a���&;z>�89�d����NߒT�m��e�����j��m�� :�����s��I�g�j���8`�,γ��� �гO���šǀ ����أ~����(�7;��B��hc
-xat�[)�<�u�8˱r	P�Ⱥ��D� ��4��*U_��t PKCS#8~r java.security.KeyRep$Type          xr java.lang.Enum          xpt PRIVATE
\ No newline at end of file
Index: Sara/private/privateKey.key
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Sara/private/privateKey.key b/Sara/private/privateKey.key
deleted file mode 100644
--- a/Sara/private/privateKey.key	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ /dev/null	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
@@ -1,15 +0,0 @@
-�� sr java.security.KeyRep��O����C L 	algorithmt Ljava/lang/String;[ encodedt [BL formatq ~ L typet Ljava/security/KeyRep$Type;xpt RSAur [B���T�  xp  �0�� 0
-	*�H��
- ��0�� � �c�V�N�{X��9P�J=8"cH���U~���~ߊ��u��(�����J�jS�&��|����&*a�g�o�q��7��Z*�2���R�B	�M�B�A
-� hZ V��<2#leL?��H%���9!UQ��٬0`|WH`���F�U9
-�	�.�EMW�h��:AC�}�pa�(�QfB�����G�-�����*�g-�@i&E_�q��ߞ��$� 4P��؉����A�u��3��'��)����N��ej+�ɡxV���y � 
-��<���[)є1c~���_�ה�E^Ա��͉S��*I���G���C:h�Q{m���~�<�0M(>�jGP>RĪ+�����R�(i8M��_�"��g���.<�Xq�u[�F,���I-���+�>�Q�E�Ƌ[�� �vF �`�Ųy�_*)���xS#* ���K�x!;��V��"�&e2�0�Y|V��e�́��B�g�!E�.�K�+0���!N���{�1ߜ����������J��;ȇ��� ��� o��]���^�<&���ԁ�E�<&�
-���]w�R��t�@d�n���'X���a��'vn��Mp���ht��P������!��E�U�Pޫ%��l�;���U�u�`Ý�J={�#��� �v��
-7��5��e��D��>ɖ
-�߆�a�y�	�� -]h�4oG���}^'
-�y��Ǔ�]��炩(��68FRD���u��UK��y���^��� ���f�z/
-�
-�Ya�� J�t^��� ����������A�9/G�o5�񞽝��{/����_"����(6~���$ň�<��tx��I���'D1~�WQ�����hu�ψ\�'B6�5��}��&����.?���'��à�/���>
-�=�FX79�$���&�J�n����BvC�L�|�U�'�}nu(���C����������wzF���0��s�R�ݜJg���ڒE�10p�;@�?��E�,<����0����x�w
-P��1�� �E���v����zx��qwq�����6���Q�(�V�Ǿ�}�婼M���w���
-��sK9�����"Kx+�p���P�	�N���fT�sNUT9Ƀ��[� ~잊�ݔ��I���݊�����^=�;��0�t PKCS#8~r java.security.KeyRep$Type          xr java.lang.Enum          xpt PRIVATE
\ No newline at end of file
Index: src/main/java/DES3.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/DES3.java b/src/main/java/DES3.java
new file mode 100644
--- /dev/null	(date 1683563461722)
+++ b/src/main/java/DES3.java	(date 1683563461722)
@@ -0,0 +1,23 @@
+import javax.crypto.Cipher;
+import javax.crypto.spec.SecretKeySpec;
+import java.util.Arrays;
+
+public class DES3 {
+    //É SUPOST SER 3DES MAS NÃO ME DEIXA CHAMAR 3DES
+    public static byte[] encrypt(byte[] message, byte[] secretKey) throws Exception {
+        byte[] secretKeyPadded = Arrays.copyOf(secretKey, 24); // 3DES key size is 24 bytes
+        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKeyPadded, "DESede");
+        Cipher cipher = Cipher.getInstance("DESede/ECB/PKCS5Padding");
+        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
+        return cipher.doFinal(message);
+    }
+
+    public static byte[] decrypt(byte[] message, byte[] secretKey) throws Exception {
+        byte[] secretKeyPadded = Arrays.copyOf(secretKey, 24); // 3DES key size is 24 bytes
+        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKeyPadded, "DESede");
+        Cipher cipher = Cipher.getInstance("DESede/ECB/PKCS5Padding");
+        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
+        return cipher.doFinal(message);
+    }
+
+}
Index: Server_G11/private/privateKey.key
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>��\u0000\u0005sr\u0000\u0014java.security.KeyRep��O����C\u0002\u0000\u0004L\u0000\talgorithmt\u0000\u0012Ljava/lang/String;[\u0000\u0007encodedt\u0000\u0002[BL\u0000\u0006formatq\u0000~\u0000\u0001L\u0000\u0004typet\u0000\u001BLjava/security/KeyRep$Type;xpt\u0000\u0003RSAur\u0000\u0002[B��\u0017�\u0006\bT�\u0002\u0000\u0000xp\u0000\u0000\u0004�0�\u0004�\u0002\u0001\u00000\r\u0006\t*�H��\r\u0001\u0001\u0001\u0005\u0000\u0004�\u0004�0�\u0004�\u0002\u0001\u0000\u0002�\u0001\u0001\u0000�\u0000���\"���\u0000�A[\u0000�wGv\u0018�6\u001A��)�ƻ\"d:�\u001385��\u001B�\n�\fY*\u0001�/q�\u001E\u0000.�/�e��3���I\u001Ax\u0002��\u001E\"�H�\u0017.#'�GB\u0001�Ic�\u001A�vW50�����\u0004��ƫ��\u000E�;\u001E�)\u0016d�\u0007ؖ�3�]�ϖ���~xo��ta��%�~ MđR��arpb����){ݷ���M��\\���ddI9{\u0004bl�~��\u0007\u0000�)^a�\\�Pl�A��A��\u0018�B�#^�Oڭ�\u001B\u0014\u007FυJ.V(\f\u001DO,i�e��Q�0��ۤ��w\u0010D�>V��\u001Cd4l�\u0014��!\u0002\u0003\u0001\u0000\u0001\u0002�\u0001\u0000L֨�\u000B�Yj�\u0001\u001C^�+\u001E����\u001C�sL\u001Eq�_o2\u0004&��g�U4�,n�:r&3\u0003q���GV��\u0000-!�H��L�\u0004`l�Z�щ�^�ذ�\u0014��&��<Ǐ�8�*\u0007�#�\"5\u000Eo\u0018�;4<\u0018\tm�'TX6\u0018Ǚ����\u0017w\u0003C+�����`4���\u001B���\u0006�\u007F\u001F��8��X\u0015{��\u001F��۹�����*0�ũ�lҨ\u001E���i��=����8�\u001D�-��*�a�RB=�y�����\u0000�q�%����L�f�\ty��A�ǽ�0��\u001E\u001C�u��j:#�W����K���u�\\;\u0002��\u0000͂�~�cX�\u0006-�\u001C�f��-�'F�����A\u0001;k�=Ēv�wJVGz�C�\u0013f�Q)s\u001F5�\u0017\u0002�vxb\tRkK�u*�\u001B\u0002\u0013�JFi���M�u� ~��&��\u001DŻ����d2d��\fz\"��\u0012��\n\u0014'�\u001E�T�z�\u007F�0[�c~�s\u0002��\u0000�͞S�7��F.�!���!�\r�b�Q�K1i�2�2�G\u0019l`�����س�\u0018��\u0006R~Q�\u0017��\nI-��j�ͼx��%�@�?P9�a�k�w�XQ≣�->I.���j>��\u001E�\u00029Ď�D?sn\u0007\u0001\u0006���^�57���[N]��\u001B\u0002��\u0000�\u0002\u0004�E5D�N�W]F\u0007h*�q?�\u001BUn��M}��@��F\u0016�\r\u0007���*�Z�3�[\f���%���XÏ64l��X\u0011�֚\u0003���\u0010�����Mb����RLz\f%X\u0004���\u000F�\n;A�:��AjVM\u0005�6�\u0003%v�e�0�\u0000��\u0013�\u0011���\u0002��i�\u0001\u000BY3T`]Xh5��)\u0010!\\�����\u001F��C�r�\u0016I�r�aS�H���1���\u0018HX��E��h�2�����\u0003\u001A:T�8ָf�W����H\u0003�1-���=�N�ϸ�t\u0003�ه\u07B7=�P�)��<�,9��(\u00195�RFU\u0019�C\u001B\u0002��|m�:�\u001F4�Q�ƙ��QG<\r�-e\u001Dtv\"6��!\\��Q�Xr�;��z�Vq��r\u0003���#<�\u0016�\u001A�n\\%�Tv}��!f�\u00180�g\u0017���H�\u001Ewޏ��HT�`�r�0F��O���m\u001B�6���+0\u007F(}\u0002��\u001E/�X���ă�t\u0000\u0006PKCS#8~r\u0000\u0019java.security.KeyRep$Type\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012\u0000\u0000xr\u0000\u000Ejava.lang.Enum\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012\u0000\u0000xpt\u0000\u0007PRIVATE
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server_G11/private/privateKey.key b/Server_G11/private/privateKey.key
--- a/Server_G11/private/privateKey.key	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ b/Server_G11/private/privateKey.key	(date 1683563464903)
@@ -1,10 +1,11 @@
 �� sr java.security.KeyRep��O����C L 	algorithmt Ljava/lang/String;[ encodedt [BL formatq ~ L typet Ljava/security/KeyRep$Type;xpt RSAur [B���T�  xp  �0�� 0
 	*�H��
- ��0�� � � ���"��� �A[ �wGv�6��)�ƻ"d:�85���
-�Y*�/q� .�/�e��3���Ix��"�H�.#'�GB�Ic��vW50�������ƫ���;�)d�ؖ�3�]�ϖ���~xo��ta��%�~ MđR��arpb����){ݷ���M��\���ddI9{bl�~�� �)^a�\�Pl�A��A���B�#^�Oڭ�υJ.V(O,i�e��Q�0��ۤ��wD�>V��d4l���! � L֨��Yj�^�+�����sLq�_o2&��g�U4�,n�:r&3q���GV�� -!�H��L�`l�Z�щ�^�ذ���&��<Ǐ�8�*�#�"5o�;4<	m�'TX6Ǚ����wC+�����`4���������8��X{����۹�����*0�ũ�lҨ���i��=����8��-��*�a�RB=�y����� �q�%����L�f�	y��A�ǽ�0���u��j:#�W����K���u�\;�� ͂�~�cX�-��f��-�'F�����A;k�=Ēv�wJVGz�C�f�Q)s5��vxb	RkK�u*��JFi���M�u� ~��&��Ż����d2d��z"����
-'��T�z��0[�c~�s�� �͞S�7��F.�!���!�
-�b�Q�K1i�2�2�Gl`�����س���R~Q���
-I-��j�ͼx��%�@�?P9�a�k�w�XQ≣�->I.���j>���9Ď�D?sn���^�57���[N]���� ��E5D�N�W]Fh*�q?�Un��M}��@��F�
-���*�Z�3�[���%���XÏ64l��X�֚��������Mb����RLz%X����
-;A�:��AjVM�6�%v�e�0� ��������i�Y3T`]Xh5��)!\�������C�r�I�r�aS�H���1���HX��E��h�2�����:T�8ָf�W����H�1-���=�N�ϸ�t�ه޷=�P�)��<�,9��(5�RFU�C��|m�:�4�Q�ƙ��QG<
-�-etv"6��!\��Q�Xr�;��z�Vq��r���#<���n\%�Tv}��!f�0�g���H�wޏ��HT�`�r�0F��O���m�6���+0(}��/�X���ă�t PKCS#8~r java.security.KeyRep$Type          xr java.lang.Enum          xpt PRIVATE
\ No newline at end of file
+ ��0�� � �ZV�ePп�w���D/�L�+�`"�l>��ה�&;��븽js+����~�����t���|hb+p>�f�yQ��ϓ^�<�w�,
+$.S��Z'�h��p�cQypK�n,|}�y6DlǴ��X��;��<w�����ŜG)��'nJh�|@$g޳���%���o ��?��%m�a��xaW�Blj��-�d���4쪝
+����V��3HG�5�����M�Ċ0;�ǌ�T��H;�絍��^���rͳ���{䱎� �  ������q	����7��4/CV���I�]
+O�������# �X2��w��b#�����R�e�n	b� ޒ��H������v٦��y"h_��r��_�@�(�r�J��^B�N�+�_\3��!ܿ1A�5���{����������é�~��改7,�ˎ���h7����ү/w�
+4HeU�D���M4�c�譖c5�^��3�wU mw�����kUE0<.��i�#��L�L����$֞�@��	X�Q�� ק�&XbP��:j As����w1
+*��K��T�7l�4�o&�`�4
+��7#k�ග�7{��rr�=�y�ܶП[�lW��:l�=�1{�����
+%��d�����tt� F�|w���F�B��"��� ����Z��/!�lx����^� #� ��I�oɑ-P���R���D?��XkB�Ī��a�ݭ��6|�t*�4�Ƽ��a��SJ7�;�v�׷G��� ���@�O��B"�����9��&���u��x�<���;H�~|������F�C�ANB���H"��c�u�v�-С�?�O�����c���	��ͧ��JR����.�Y�Zw��
+~���k& �0���*�i.�ԥ(�j�IMQ�#�/\(;%bA��?52KG&̰/ZM��O�w&,z�t�[���U|�S���7�1fG���)J����V��AUj�vOHٸ�!���-B�v����A�d/��8(�{�J>�rx ��>k�J5���K�]7��� �Z�����q�Bi*�5e�TV�Q��ǣ3يSc-oR;����/#�_�F��]Y�y�˦Ś����D�M�#3XX�K����"���tZ����ay��b;am�օ���س*�tH��k@!�E�t PKCS#8~r java.security.KeyRep$Type          xr java.lang.Enum          xpt PRIVATE
\ No newline at end of file
Index: server/Registry/registry.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Sara : 1\r\nStere : 1\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server/Registry/registry.txt b/server/Registry/registry.txt
--- a/server/Registry/registry.txt	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ b/server/Registry/registry.txt	(date 1683563497544)
@@ -1,2 +1,1 @@
 Sara : 1
-Stere : 1
