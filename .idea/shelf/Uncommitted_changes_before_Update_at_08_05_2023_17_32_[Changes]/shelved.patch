Index: src/main/java/Client.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.crypto.SecretKey;\r\nimport java.io.*;\r\nimport java.math.BigInteger;\r\nimport java.net.Socket;\r\nimport java.nio.file.Files;\r\nimport java.security.KeyPair;\r\nimport java.util.ArrayList;\r\nimport java.util.Scanner;\r\nimport java.security.KeyPair;\r\nimport java.security.PrivateKey;\r\nimport java.security.PublicKey;\r\n\r\n/**\r\n * This class represents the client. The client sends the messages to the server by means of a socket. The use of Object\r\n * streams enables the sender to send any kind of object.\r\n */\r\npublic class Client {\r\n    private static final String HOST = \"0.0.0.0\";\r\n    private final Socket client;\r\n    private final ObjectInputStream in;\r\n    private final ObjectOutputStream out;\r\n    private boolean isConnected;\r\n    private String client_name;\r\n    private PrivateKey privateKey;\r\n    private PublicKey publicKey;\r\n    private SecretKey macKey;\r\n    private int requestLimit;\r\n    private String fileName;\r\n    private PublicKey serverPublicRSAKey;\r\n    private static final Scanner scan = new Scanner(System.in);\r\n    private BigInteger sharedSecret;\r\n    private ArrayList<Integer> choice;       // get(0) - Hashing algorithm       get(1) - Encryption algorithm\r\n                                                                        //    0 - MAC    1 - Hash                   0 - AES   1 -\r\n    /**\r\n     * Constructs a Client object by specifying the port to connect to. The socket must be created before the sender can\r\n     * send a message.\r\n     *\r\n     * @param port the port to connect to\r\n     * @throws IOException when an I/O error occurs when creating the socket\r\n     */\r\n    public Client(int port) throws Exception {\r\n        this.requestLimit = 0;\r\n\r\n        client = new Socket ( HOST , port );\r\n\r\n        out = new ObjectOutputStream ( client.getOutputStream ( ) );\r\n\r\n        in = new ObjectInputStream ( client.getInputStream ( ) );\r\n\r\n        isConnected = true; // TODO: Check if this is necessary or if it should be controlled\r\n\r\n        // Create a temporary directory for putting the request files\r\n\r\n        //userDir = Files.createTempDirectory ( \"fileServer\" ).toFile ( ).getAbsolutePath ( );\r\n\r\n        System.out.println(\"\\nInsert your username\");\r\n        String name = scan.next();\r\n        this.client_name = name;\r\n\r\n        RSA.storeRSAKeys ( RSA.generateKeyPair() , client_name);\r\n\r\n        this.setPrivateKey();\r\n        this.setPublicKey();\r\n\r\n\r\n    }\r\n    public String getClientName() {\r\n        return client_name;\r\n    }\r\n    public void setClientName(String client_name){\r\n        this.client_name = client_name;\r\n    }\r\n    public void setPrivateKey() throws Exception{ this.privateKey = RSA.getPrivateKey(this.client_name); }\r\n    public void setPublicKey() throws Exception{ this.publicKey = RSA.getPublicKey(this.client_name); }\r\n    public PrivateKey getPrivateKey() throws Exception{ return this.privateKey; }\r\n    public PublicKey getPublicKey() throws Exception{ return RSA.getPublicKey(this.client_name); }\r\n    public void setFileName(String request){\r\n        this.fileName = request;\r\n    }\r\n\r\n    public String getFileName() {\r\n        return this.fileName;\r\n    }\r\n\r\n    public void setConnected(boolean bool) {\r\n        this.isConnected = bool;\r\n    }\r\n\r\n    public boolean doHandshake() throws Exception {\r\n        boolean handshakeInsuccess = false;\r\n        boolean invalid_choice_hashing = false;\r\n        boolean invalid_choice_encryption = false;\r\n        choice = new ArrayList<Integer>(); //Array novo sempre que isto Ã© chamado\r\n\r\n        System.out.println(\"\\nWe will make you set up your commmunication and security, cause I want 20.\");\r\n\r\n        // choice.get(0)\r\n        System.out.println(\"\\nHashing algoritm:\");\r\n        System.out.println(\"0. MAC\");\r\n        System.out.println(\"1. Hash of 512 bits (SHA - 512)\");\r\n        System.out.println(\"2. 2048 eggs & bacon\");\r\n        System.out.println(\"3. CBC\");\r\n        int i = scan.nextInt();\r\n        switch (i){\r\n            case 0:\r\n                choice.add(0); // [0] = 0\r\n                break;\r\n            case 1:\r\n                choice.add(1); // [0] = 1\r\n                break;\r\n            case 2:\r\n                invalid_choice_hashing = true;\r\n                break;\r\n            case 3:\r\n                invalid_choice_hashing = true;\r\n                break;\r\n        }\r\n        // choice.get(1)\r\n        System.out.println(\"\\nEncryption/Decryption algoritm:\");\r\n        System.out.println(\"0. AES\");\r\n        System.out.println(\"1. DES\");\r\n        System.out.println(\"2. 360-no-scope-DES\");\r\n        System.out.println(\"3. CBC\");\r\n        i = scan.nextInt();\r\n        switch (i){\r\n            case 0:\r\n                choice.add(0); // [1] = 0\r\n                break;\r\n            case 1:\r\n                choice.add(1); // [1] = 1\r\n                break;\r\n            case 2:\r\n                invalid_choice_encryption = true;\r\n                break;\r\n            case 3:\r\n                invalid_choice_encryption = true;\r\n                break;\r\n        }\r\n\r\n        //Faz o handshake\r\n        if(invalid_choice_hashing == false && invalid_choice_encryption == false){\r\n            serverPublicRSAKey = rsaKeyDistribution();\r\n            sharedSecret = agreeOnSharedSecret ( serverPublicRSAKey );\r\n\r\n            macKey=MAC.createMACKey();\r\n            System.out.println(choice);\r\n            sendClientChoice();\r\n\r\n            if(choice.get(0) == 0){\r\n                sendMacKey();\r\n            }\r\n        }else{\r\n            handshakeInsuccess = true;\r\n            System.out.println(\"This server doesn't support those algorithms.\");\r\n        }\r\n        return handshakeInsuccess;\r\n    }\r\n    public void sendClientChoice() throws IOException {\r\n        out.writeObject(choice);\r\n        out.flush ();\r\n    }\r\n    public void endConnection() throws Exception {\r\n        this.closeConnection();\r\n    }\r\n\r\n    /**\r\n     * Reads the response from the server and writes the file to the temporary directory.\r\n     *\r\n     * @param fileName the name of the file to write\r\n     */\r\n    private void processResponse(String fileName) throws Exception {\r\n        String unitedMessage = \"\";\r\n\r\n        //BigInteger sharedSecret = agreeOnSharedSecret(serverPublicRSAKey);\r\n\r\n        Message response = (Message) in.readObject();\r\n        byte[] decryptedFile = null;\r\n        //CRYPTO\r\n        if(choice.get(1) == 0) {\r\n            decryptedFile = AES.decrypt(response.getMessage(), sharedSecret.toByteArray());\r\n        }else if(choice.get(1) == 1){\r\n            decryptedFile = DES.decrypt(response.getMessage(), sharedSecret.toByteArray());\r\n\r\n        }\r\n        //HASHING\r\n        byte[] computedDigest = null;\r\n        if(choice.get(0) == 0) {\r\n            computedDigest = MAC.generateMAC(decryptedFile, macKey);\r\n            if (!MAC.verifyMAC(response.getSignature(), computedDigest)) {\r\n                throw new RuntimeException(\"The integrity of the message is not verified\");\r\n            }\r\n        }else if(choice.get(0) == 1){\r\n            computedDigest = Hash.generateDigest(decryptedFile);\r\n            if (!Hash.verifyDigest(response.getSignature(), computedDigest)) {\r\n                throw new RuntimeException(\"The integrity of the message is not verified\");\r\n            }\r\n        }\r\n\r\n        String decryptedContent = new String(decryptedFile);  // To handle divided content\r\n\r\n        if (decryptedContent.equals(\"INICIO\")) { //Decrypts this first message - INICIO\r\n\r\n            //System.out.println(\"Recebeu o inicio\");\r\n\r\n            while (!decryptedContent.equals(\"FIM\")){ //Decrypts the rest of the message until we get the last message - FIM\r\n\r\n                response = (Message) in.readObject();\r\n                //CRYPTO\r\n                if(choice.get(1) == 0) {\r\n                    decryptedFile = AES.decrypt(response.getMessage(), sharedSecret.toByteArray());\r\n                }else if(choice.get(1) == 1){\r\n                    decryptedFile = DES.decrypt(response.getMessage(), sharedSecret.toByteArray());\r\n\r\n                }\r\n                //HASHING\r\n                if(choice.get(0) == 0) {\r\n                    computedDigest = MAC.generateMAC(decryptedFile, macKey);\r\n                    if (!MAC.verifyMAC(response.getSignature(), computedDigest)) {\r\n                        throw new RuntimeException(\"The integrity of the message is not verified\");\r\n                    }\r\n                }else if(choice.get(0) == 1){\r\n                    computedDigest = Hash.generateDigest(decryptedFile);\r\n                    if (!Hash.verifyDigest(response.getSignature(), computedDigest)) {\r\n                        throw new RuntimeException(\"The integrity of the message is not verified\");\r\n                    }\r\n                }\r\n\r\n                decryptedContent = new String(decryptedFile);\r\n\r\n                unitedMessage +=new String(decryptedFile);\r\n            }\r\n            System.out.println(\"We have reached the end of the file content.\");\r\n\r\n            System.out.println(\"This is the file content:\");\r\n\r\n            System.out.println(new String (unitedMessage));\r\n\r\n            saveFiles(unitedMessage);\r\n\r\n        }else{\r\n            saveFiles(new String(decryptedFile));\r\n        }\r\n    }\r\n\r\n    public void saveFiles(String decryptedFile) throws Exception{\r\n        //CriaÃ§Ã£o da pasta que receberÃ¡ os ficheiros\r\n        String privateClientPath = this.client_name + \"/files\";\r\n        File privateClientFolder = new File(privateClientPath);\r\n        privateClientFolder.mkdirs();\r\n\r\n        //CriaÃ§Ã£o do ficheiro de texto que receberÃ¡ o conteÃºdo do ficheiro de texto pedido e a escrita do mesmo\r\n        String decryptedFileString = decryptedFile;\r\n        File arquivo = new File(this.client_name + \"/files/User_\" + this.getFileName());\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(arquivo));\r\n        bw.write(decryptedFileString);\r\n        bw.close();\r\n    }\r\n    /**\r\n     * Closes the connection by closing the socket and the streams.\r\n     */\r\n    private void closeConnection ( ) {\r\n        try {\r\n            client.close ( );\r\n            out.close ( );\r\n            in.close ( );\r\n        } catch ( IOException e ) {\r\n            throw new RuntimeException ( e );\r\n        }\r\n    }\r\n\r\n    private void sendPublicDHKey ( byte[] publicKey ) throws Exception {\r\n        out.writeObject ( publicKey );\r\n    }\r\n\r\n    private PublicKey rsaKeyDistribution ( ) throws Exception {\r\n        // Sends the public key\r\n        sendPublicRSAKey ( );\r\n        // Receive the public key of the sender\r\n        return ( PublicKey ) in.readObject ( );\r\n    }\r\n\r\n    private void sendPublicRSAKey ( ) throws IOException {\r\n        out.writeObject ( publicKey );\r\n        out.flush ( );\r\n    }\r\n    private void sendMacKey() throws Exception{\r\n        out.writeObject(macKey);\r\n        out.flush ();\r\n    }\r\n    public void sendMessage ( String message ) throws Exception {\r\n        // Agree on a shared secret\r\n        // BigInteger sharedSecret = agreeOnSharedSecret ( serverPublicRSAKey );\r\n        // Encrypts the message\r\n        byte[] encryptedMessage = null;\r\n        if(choice.get(1) == 0){ //AES\r\n            encryptedMessage = AES.encrypt ( message.getBytes ( ) , sharedSecret.toByteArray ( ) );\r\n        }\r\n        if(choice.get(1) == 1){ //DES\r\n            encryptedMessage = DES.encrypt ( message.getBytes ( ) , sharedSecret.toByteArray ( ) );\r\n        }\r\n        byte[] digest = null;\r\n\r\n        if(choice.get(0) == 0){ //MAC\r\n            // Generates the MAC\r\n            digest = MAC.generateMAC(message.getBytes ( ),macKey);\r\n        }else if(choice.get(0) == 1){ //HASH\r\n            digest = Hash.generateDigest(message.getBytes ( ));\r\n        }\r\n        // Creates the message object\r\n        Message messageObj = new Message ( encryptedMessage , digest );\r\n        // Sends the encrypted message\r\n        out.writeObject ( messageObj );\r\n        out.flush();\r\n    }\r\n    private BigInteger agreeOnSharedSecret (PublicKey serverPublicRSAKey ) throws Exception {\r\n        // Generates a private key\r\n        BigInteger privateDHKey = DiffieHellman.generatePrivateKey ( );\r\n        BigInteger publicDHKey = DiffieHellman.generatePublicKey ( privateDHKey );\r\n        // Sends the public key to the server encrypted\r\n        sendPublicDHKey ( RSA.encryptRSA ( publicDHKey.toByteArray ( ) , privateKey ) );\r\n        // Waits for the server to send his public key\r\n        BigInteger serverPublicKey = new BigInteger ( RSA.decryptRSA ( ( byte[] ) in.readObject ( ) , serverPublicRSAKey ) );\r\n        // Generates the shared secret\r\n        return DiffieHellman.computePrivateKey ( serverPublicKey , privateDHKey );\r\n    }\r\n\r\n    /**\r\n     * Executes the client. It reads the file from the console and sends it to the server. It waits for the response and\r\n     * writes the file to the temporary directory.\r\n     */\r\n    public void execute() throws Exception{\r\n        Scanner usrInput = new Scanner ( System.in );\r\n        if( isConnected ) {\r\n            // Reads the message to extract the path of the file\r\n            System.out.println ( \"Write the path of the file\" );\r\n            String request = \"USERNAME: \"+this.client_name+ \": \"+usrInput.nextLine ( );\r\n            this.setFileName(RequestUtils.splitRequest(request).get(1));\r\n            // Request the file\r\n            sendMessage ( request );\r\n            // Waits for the response\r\n            processResponse ( RequestUtils.getFileNameFromRequest ( request ) );\r\n        }\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Client.java b/src/main/java/Client.java
--- a/src/main/java/Client.java	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ b/src/main/java/Client.java	(date 1683563461728)
@@ -119,8 +119,8 @@
         System.out.println("\nEncryption/Decryption algoritm:");
         System.out.println("0. AES");
         System.out.println("1. DES");
-        System.out.println("2. 360-no-scope-DES");
-        System.out.println("3. CBC");
+        System.out.println("2. 3DES");
+        System.out.println("3. 360-no-scope-DES");
         i = scan.nextInt();
         switch (i){
             case 0:
@@ -130,7 +130,7 @@
                 choice.add(1); // [1] = 1
                 break;
             case 2:
-                invalid_choice_encryption = true;
+                choice.add(2); // [1] = 2
                 break;
             case 3:
                 invalid_choice_encryption = true;
@@ -178,9 +178,12 @@
         //CRYPTO
         if(choice.get(1) == 0) {
             decryptedFile = AES.decrypt(response.getMessage(), sharedSecret.toByteArray());
-        }else if(choice.get(1) == 1){
+        }
+        if(choice.get(1) == 1){
             decryptedFile = DES.decrypt(response.getMessage(), sharedSecret.toByteArray());
-
+        }
+        if(choice.get(1) == 2){
+            decryptedFile = DES3.decrypt(response.getMessage(), sharedSecret.toByteArray());
         }
         //HASHING
         byte[] computedDigest = null;
@@ -208,9 +211,12 @@
                 //CRYPTO
                 if(choice.get(1) == 0) {
                     decryptedFile = AES.decrypt(response.getMessage(), sharedSecret.toByteArray());
-                }else if(choice.get(1) == 1){
+                }
+                if(choice.get(1) == 1){
                     decryptedFile = DES.decrypt(response.getMessage(), sharedSecret.toByteArray());
-
+                }
+                if(choice.get(1) == 2){
+                    decryptedFile = DES3.decrypt(response.getMessage(), sharedSecret.toByteArray());
                 }
                 //HASHING
                 if(choice.get(0) == 0) {
@@ -298,6 +304,10 @@
         if(choice.get(1) == 1){ //DES
             encryptedMessage = DES.encrypt ( message.getBytes ( ) , sharedSecret.toByteArray ( ) );
         }
+        if(choice.get(1) == 2){
+            encryptedMessage = DES3.encrypt(message.getBytes(), sharedSecret.toByteArray());
+        }
+
         byte[] digest = null;
 
         if(choice.get(0) == 0){ //MAC
Index: src/main/java/ClientHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.crypto.SecretKey;\r\nimport java.io.IOException;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.math.BigInteger;\r\nimport java.net.Socket;\r\nimport java.security.PublicKey;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * This class represents the client handler. It handles the communication with the client. It reads the file from the\r\n * server and sends it to the client.\r\n */\r\npublic class ClientHandler extends Thread {\r\n    private final ObjectInputStream in;\r\n    private final ObjectOutputStream out;\r\n    private final Socket client;\r\n    private ArrayList<String> requestSplit;\r\n    private SecretKey clientMACKey;\r\n    private ArrayList<Integer> clientChoice;\r\n\r\n    /**\r\n     * Creates a ClientHandler object by specifying the socket to communicate with the client. All the processing is\r\n     * done in a separate thread.\r\n     *\r\n     * @throws IOException when an I/O error occurs when creating the socket\r\n     */\r\n    public ClientHandler (Socket client) throws Exception {\r\n        this.client = client;\r\n        in = new ObjectInputStream ( this.client.getInputStream ( ) );\r\n        out = new ObjectOutputStream ( this.client.getOutputStream ( ) );\r\n        boolean isConnected = true; // TODO: Check if this is necessary or if it should be controlled\r\n    }\r\n\r\n    @Override\r\n    public void run ( ) {\r\n        super.run ( );\r\n        try {\r\n            sleep(2000);\r\n            PublicKey clientPublicRSAKey;\r\n\r\n            while(RequestUtils.readNumberFromFile(RequestUtils.HANDSHAKE_SIGNAL) != 1){  }\r\n\r\n            clientPublicRSAKey = rsaKeyDistribution ( in );\r\n            BigInteger sharedSecret = agreeOnSharedSecret ( clientPublicRSAKey );\r\n            System.out.println(\"SERVER : Handshake was a sucess.\");\r\n\r\n\r\n            clientChoice = receiveClientChoice();\r\n            System.out.print(\"SERVER : Client setup \");\r\n            printClientChoice(clientChoice);\r\n\r\n            if(clientChoice.get(0) == 0){\r\n                clientMACKey = receiveMacKey();\r\n                System.out.println(\"SERVER : MACK Key received.\");\r\n            }\r\n\r\n            int i = 0;\r\n            while ( i != 5) {\r\n\r\n                byte[] message = process ( in , sharedSecret.toByteArray ( ), clientChoice );\r\n\r\n                if(message != null ){\r\n                    System.out.println(\"\\n***** REQUEST *****\\n\"+ new String(message));\r\n\r\n                    //Splits message received\r\n\r\n                    requestSplit = RequestUtils.splitRequest(new String(message));\r\n\r\n                    //Regista os nÃºmero de pedidos feitos por este utilizador\r\n\r\n                    RequestUtils.registerRequests (requestSplit);\r\n\r\n                    // Reads the file and sends it to the client\r\n\r\n                    byte[] content = FileHandler.readFile ( RequestUtils.getAbsoluteFilePath ( requestSplit.get(1) ) );\r\n\r\n                    String auxContent = new String(content);\r\n                    System.out.println(\"\\n***** FILE ********\\nHere's the file content: \");\r\n                    System.out.println(auxContent);\r\n\r\n                    int contentSize = content.length;\r\n                    //int numParts = (int) Math.ceil((double) contentSize / 2048);\r\n\r\n                    if(contentSize>2048) {\r\n\r\n                        sendFile(\"INICIO\".getBytes(), sharedSecret.toByteArray (), clientChoice);\r\n\r\n                        ArrayList<byte[]> contentDividido = ByteUtils.splitByteArray(auxContent.getBytes(),2048 );\r\n\r\n                        for (int j = 0; j < contentDividido.size(); j++) {\r\n\r\n                            sendFile(contentDividido.get(j), sharedSecret.toByteArray (), clientChoice);\r\n                            System.out.println(new String(contentDividido.get(j)));\r\n\r\n                        }\r\n                        sendFile(\"FIM\".getBytes(), sharedSecret.toByteArray (), clientChoice);\r\n                    }\r\n                    else {\r\n\r\n                        sendFile(content, sharedSecret.toByteArray (), clientChoice);\r\n\r\n                    }\r\n                    i = RequestUtils.requestLimit(requestSplit.get(0));\r\n\r\n                    //System.out.println(requestSplit.get(0)+\" - Request counter: \"+i);\r\n\r\n                }\r\n            }\r\n            if(i >= 5){\r\n\r\n                System.out.println(\"\\nClient \"+requestSplit.get(0) +\" exceeded the max requests.\");\r\n\r\n                RequestUtils.resetRequestCounter(requestSplit.get(0));\r\n\r\n                System.out.println(\"Client \"+requestSplit.get(0) +\" request counter has been reset to 0.\");\r\n            }\r\n\r\n            System.out.println(\"Closing socket connection.\");\r\n\r\n            closeConnection ( );\r\n        } catch ( IOException | ClassNotFoundException e ) {\r\n\r\n            closeConnection ( );\r\n\r\n        } catch (Exception e) {\r\n\r\n            throw new RuntimeException(e);\r\n\r\n        }\r\n    }\r\n    public void printClientChoice(ArrayList<Integer> clientChoice){\r\n        switch (clientChoice.get(0)) {\r\n            case 0:\r\n                System.out.print(\"[ MAC , \");\r\n                break;\r\n            case 1:\r\n                System.out.print(\"[ HASH , \");\r\n                break;\r\n        }\r\n        switch (clientChoice.get(1)) {\r\n            case 0:\r\n                System.out.print(\"AES ]\");\r\n                break;\r\n            case 1:\r\n                System.out.print(\"DES ]\");\r\n                break;\r\n        }\r\n        System.out.println(\"\\n\");\r\n    }\r\n    public static List<String> splitStringBySize(String input) {\r\n        List<String> output = new ArrayList<>();\r\n\r\n        // Verifica o tamanho da string em bytes\r\n        int inputSize = input.getBytes().length;\r\n\r\n        if (inputSize <= 2048) { // Se o tamanho for menor ou igual a 2KB, adiciona a string inteira na lista de saÃ­da\r\n            output.add(input);\r\n        } else { // Caso contrÃ¡rio, divide a string em pedaÃ§os de no mÃ¡ximo 2KB\r\n            int numParts = (int) Math.ceil((double) inputSize / 2048); // Calcula o nÃºmero de pedaÃ§os necessÃ¡rios\r\n            int remainingBytes = inputSize;\r\n            int start = 0;\r\n            int end = 0;\r\n\r\n            for (int i = 0; i < numParts; i++) {\r\n                end += (remainingBytes > 2048) ? 2048 : remainingBytes; // Define o final do pedaÃ§o, garantindo que nÃ£o ultrapasse 2KB\r\n                String part = input.substring(start, end); // Extrai o pedaÃ§o da string original\r\n                output.add(part); // Adiciona o pedaÃ§o na lista de saÃ­da\r\n                start = end;\r\n                remainingBytes = inputSize - end;\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n\r\n    /**\r\n     * Sends the file to the client\r\n     *\r\n     * @param content the content of the file to send\r\n     *\r\n     * @throws IOException when an I/O error occurs when sending the file\r\n     */\r\n    private void sendFile ( byte[] content , byte[] sharedSecret , ArrayList<Integer> choice) throws Exception {\r\n        byte[] encryptedResponse = null;\r\n\r\n        if(choice.get(1) == 0){ //AES\r\n            encryptedResponse = AES.encrypt ( content , sharedSecret );\r\n        }\r\n        if(choice.get(1) == 1){ //DES\r\n            encryptedResponse = DES.encrypt ( content , sharedSecret );\r\n        }\r\n        byte[] digest = null;\r\n\r\n        if(choice.get(0) == 0){ //MAC\r\n            // Generates the MAC\r\n            digest = MAC.generateMAC ( content, clientMACKey );\r\n        }else if(choice.get(0) == 1){ //HASH\r\n            digest = Hash.generateDigest(content);\r\n        }\r\n        // Creates the message object\r\n        Message responseObj = new Message ( encryptedResponse , digest );\r\n        // Sends the encrypted message\r\n        out.writeObject ( responseObj );\r\n        out.flush ( );\r\n    }\r\n\r\n    /**\r\n     * Closes the connection by closing the socket and the streams.\r\n     */\r\n    private void closeConnection ( ) {\r\n        try {\r\n            client.close ( );\r\n            out.close ( );\r\n            in.close ( );\r\n        } catch ( IOException e ) {\r\n            throw new RuntimeException ( e );\r\n        }\r\n    }\r\n    private SecretKey receiveMacKey() throws IOException, ClassNotFoundException {\r\n        SecretKey macKey = ( SecretKey ) in.readObject ( );\r\n        return macKey;\r\n    }\r\n    private ArrayList<Integer> receiveClientChoice () throws IOException, ClassNotFoundException {\r\n        ArrayList<Integer> choice = (ArrayList<Integer>) in.readObject();\r\n        return choice;\r\n    }\r\n    //DIFFIE HELLLMAN\r\n    private PublicKey rsaKeyDistribution (ObjectInputStream in ) throws Exception {\r\n        // Extract the public key\r\n        PublicKey senderPublicRSAKey = ( PublicKey ) in.readObject ( );\r\n        // Send the public key\r\n        sendPublicRSAKey ( );\r\n        return senderPublicRSAKey;\r\n    }\r\n    private void sendPublicRSAKey ( ) throws Exception {\r\n        out.writeObject ( Server.getPublicRSAKey());\r\n        out.flush ( );\r\n    }\r\n\r\n    private void sendPublicDHKey ( BigInteger publicKey ) throws Exception {\r\n        out.writeObject ( RSA.encryptRSA ( publicKey.toByteArray ( ) , Server.getPrivateRSAKey()));\r\n    }\r\n    /**\r\n     * Performs the Diffie-Hellman algorithm to agree on a shared private key.\r\n     *\r\n     * @param senderPublicRSAKey the public key of the sender\r\n     *\r\n     * @return the shared secret key\r\n     *\r\n     * @throws Exception when the key agreement protocol fails\r\n     */\r\n    private BigInteger agreeOnSharedSecret ( PublicKey senderPublicRSAKey ) throws Exception {\r\n        // Generate a pair of keys\r\n        BigInteger privateKey = DiffieHellman.generatePrivateKey ( );\r\n        BigInteger publicKey = DiffieHellman.generatePublicKey ( privateKey );\r\n        // Extracts the public key from the request\r\n        BigInteger clientPublicKey = new BigInteger ( RSA.decryptRSA ( ( byte[] ) in.readObject ( ) , senderPublicRSAKey ) );\r\n        // Send the public key to the client\r\n        sendPublicDHKey ( publicKey );\r\n        // Generates the shared secret\r\n        return DiffieHellman.computePrivateKey ( clientPublicKey , privateKey );\r\n    }\r\n\r\n    private byte[] process ( ObjectInputStream in , byte[] sharedSecret, ArrayList<Integer> clientChoice ) throws Exception {\r\n        // Reads the message object\r\n        Message messageObj = ( Message ) in.readObject ( );\r\n        // Extracts and decrypt the message\r\n        byte[] decryptedMessage = null;\r\n        if(clientChoice.get(1) == 0){\r\n            decryptedMessage = AES.decrypt ( messageObj.getMessage ( ) , sharedSecret );\r\n        }\r\n        if(clientChoice.get(1) == 1){\r\n            decryptedMessage = DES.decrypt ( messageObj.getMessage ( ) , sharedSecret );\r\n        }\r\n        // Computes the digest of the received message\r\n        byte[] computedDigest = null;\r\n        if(clientChoice.get(0) == 0){\r\n            computedDigest = MAC.generateMAC ( decryptedMessage, clientMACKey );\r\n            if ( ! MAC.verifyMAC ( messageObj.getSignature ( ) , computedDigest ) ) {\r\n                throw new RuntimeException ( \"The integrity of the message is not verified\" );\r\n            }\r\n        }\r\n        if (clientChoice.get(0) == 1){\r\n            //decryptedMessage = 3DES.decrypt ( messageObj.getMessage ( ) , sharedSecret );\r\n            computedDigest = Hash.generateDigest(decryptedMessage);\r\n            if ( ! Hash.verifyDigest ( messageObj.getSignature ( ) , computedDigest ) ) {\r\n                throw new RuntimeException ( \"The integrity of the message is not verified\" );\r\n            }\r\n        }\r\n        // Verifies the integrity of the message\r\n\r\n        return decryptedMessage;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ClientHandler.java b/src/main/java/ClientHandler.java
--- a/src/main/java/ClientHandler.java	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ b/src/main/java/ClientHandler.java	(date 1683563461734)
@@ -30,7 +30,6 @@
         this.client = client;
         in = new ObjectInputStream ( this.client.getInputStream ( ) );
         out = new ObjectOutputStream ( this.client.getOutputStream ( ) );
-        boolean isConnected = true; // TODO: Check if this is necessary or if it should be controlled
     }
 
     @Override
@@ -146,6 +145,9 @@
             case 1:
                 System.out.print("DES ]");
                 break;
+            case 2:
+                System.out.print("3DES ]");
+                break;
         }
         System.out.println("\n");
     }
@@ -192,6 +194,9 @@
         if(choice.get(1) == 1){ //DES
             encryptedResponse = DES.encrypt ( content , sharedSecret );
         }
+        if(choice.get(1) == 2){ //DES
+            encryptedResponse = DES3.encrypt ( content , sharedSecret );
+        }
         byte[] digest = null;
 
         if(choice.get(0) == 0){ //MAC
@@ -275,6 +280,9 @@
         if(clientChoice.get(1) == 1){
             decryptedMessage = DES.decrypt ( messageObj.getMessage ( ) , sharedSecret );
         }
+        if(clientChoice.get(1) == 2){
+            decryptedMessage = DES3.decrypt ( messageObj.getMessage ( ) , sharedSecret );
+        }
         // Computes the digest of the received message
         byte[] computedDigest = null;
         if(clientChoice.get(0) == 0){
Index: Re/private/privateKey.key
===================================================================
diff --git a/Re/private/privateKey.key b/Re/private/privateKey.key
deleted file mode 100644
--- a/Re/private/privateKey.key	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ /dev/null	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
@@ -1,11 +0,0 @@
-ï¿½ï¿½ sr java.security.KeyRepï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½C L 	algorithmt Ljava/lang/String;[ encodedt [BL formatq ~ L typet Ljava/security/KeyRep$Type;xpt RSAur [Bï¿½ï¿½ï¿½Tï¿½  xp  ï¿½0ï¿½ï¿½ 0
-	*ï¿½Hï¿½ï¿½
- ï¿½ï¿½0ï¿½ï¿½ ï¿½ ï¿½Eï¿½DP{ï¿½ï¿½vÚ´2{ï¿½i~ï¿½=ï¿½'ï¿½ts[
-!ï¿½^ï¿½rï¿½s3(0ï¿½ï¿½a?aï¿½ï¿½Hï¿½Äï¿½Xï¿½ï¿½ï¿½cX}Pï¿½6wï¿½ï¿½dï¿½ï¿½ï¿½ï¿½ï¿½z7ÃºWp 3|ï¿½ï¿½ ~gï¿½ï¿½y(ï¿½2ï¿½ï¿½5ï¿½ï¿½,Xï¿½ï¿½ï¿½r9}JKï¿½Iï¿½ï¿½Pï¿½ï¿½&ï¿½ï¿½qï¿½ï¿½ï¿½eï¿½ï¿½é•ï¿½ï¿½;ï¿½ï¿½I3j	/ï¿½ï¿½TaKï¿½ï¿½ï¿½Hï¿½ï¿½	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½*Ä ï¿½2k ?]vï¿½t"zï¿½lï¿½6_,ï¿½Tï¿½uï¿½&ï¿½
-ï¿½ï¿½×ºï¿½ï¿½ï¿½o ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½;ï¿½]2é±©ï¿½
-ï¿½Ğ…ï¿½ï¿½ï¿½ ï¿½l>Q0ï¿½ï¿½ï¿½ltï¿½5i_I ï¿½ |ï¿½EË¬ï¿½/ï¿½Vfï¿½ï¿½ï¿½ï¿½V	ï¿½Q\!duï¿½NVï¿½ï¿½ï¿½.9ï¿½cï¿½ï¿½á–ï¿½oØ$qï¿½ï¿½ï¿½=^ï¿½ï¿½Gï¿½ï¿½8ï¿½9/7ï¿½-Xcï¿½,4ï¿½hï¿½ï¿½ï¿½ï¿½Iï¿½>ï¿½ï¿½3ï¿½2ï¿½Ü±ï¿½ï¿½ï¿½ï¿½5yjï¿½ï¿½ï¿½Iï¿½
-ï¿½ï¿½È·ï¿½(ï¿½2ï¿½ï¿½Ó¢qï¿½ï¿½ï¿½{ï¿½-ï¿½ï¿½&Ñ‚[Pï¿½jï¿½4ï¿½%ï¿½ï¿½ï¿½ï¿½Ø‹ï¿½Dï¿½![rï¿½ï¿½;ï¿½kï¿½.6Ô¼@ï¿½ï¿½+Qï¿½q!ï¿½D0m8ï¿½ï¿½Â§ï¿½ wï¿½ï¿½<ï¿½~
-ï¿½Â\ï¿½ï¿½uï¿½hï¿½ Ó—\0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½NXï¿½xÕ‚Uï¿½ï¿½Cï¿½.M}=ï¿½ï¿½ï¿½zaï¿½ï¿½ ï¿½ï¿½ >.ï¿½:ï¿½mï¿½}ï¿½ï¿½ï¿½ï¿½RAï¿½ï¿½+ï¿½ï¿½wp*ï¿½YYV%ï¿½`ï¿½Uï¿½^ï¿½(ï¿½ï¿½ï¿½ï¿½5ï¿½X'cYï¿½5(ï¿½ï¿½ï¿½ï¿½Tï¿½Ğ£:ï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½O\ï¿½ï¿½]ï¿½*h
-ï¿½M!0yAï¿½4ï¿½mï¿½?mqEVÛƒ\ï¿½ï¿½tHï¿½ï¿½Zaï¿½ï¿½ ï¿½Ê¾:\ï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½?ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½Zmtï¿½P8.1ï¿½Gï¿½×¼ï¿½vwï¿½ptGï¿½Ëˆ9ï¿½Iï¿½ï¿½?ï¿½Uï¿½ï¿½dï¿½(Ë¯ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½[!Bï¿½_ï¿½9 IU×œï¿½Dbï¿½ï¿½*Nï¿½ï¿½ï¿½`ï¿½vï¿½ï¿½UMï¿½aï¿½=ï¿½ï¿½ï¿½ ï¿½Hï¿½5ï¿½Ï¢ï¿½ï¿½~ï¿½}ï¿½!Jï¿½:ï¿½Ä¢ï¿½ï¿½ï¿½ï¿½ï¿½Ï›ï¿½=ï¿½w^A%ï¿½ï¿½ï¿½4ï¿½ï¿½Xï¿½ï¿½ï¿½Â­ï¿½ï¿½oï¿½*Nï¿½ï¿½.ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½wé¸—ï¿½2,UXï¿½\5POï¿½Jï¿½ï¿½Vï¿½bÆ´ï¿½i*İŸtjï¿½3ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½ï¿½]ï¿½×—ï¿½ï¿½ï¿½z)ï¿½ï¿½ï¿½ï¿½;(FwM,{~ï¿½Yï¿½Mï¿½|ï¿½Ê­,ï¿½ï¿½tï¿½Xï¿½m;ï¿½ï¿½gï¿½Aï¿½ï¿½ï¿½^{oï¿½g ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½#%_ï¿½E-ï¿½2Oï¿½ï¿½Aï¿½Mï¿½ï¿½Cï¿½ï¿½ ï¿½ï¿½ï¿½T"ï¿½kAï¿½Ëªq!?(ï¿½)
-ï¿½#974ï¿½aï¿½ï¿½ï¿½&;z>ï¿½89ï¿½dï¿½ï¿½ï¿½ï¿½Nß’Tï¿½mï¿½ï¿½eï¿½ï¿½ï¿½ï¿½ï¿½jï¿½ï¿½mï¿½ï¿½ :ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½Iï¿½gï¿½jï¿½ï¿½ï¿½8`ï¿½,Î³ï¿½ï¿½ï¿½ ï¿½Ğ³Oï¿½ï¿½ï¿½Å¡Ç€ ï¿½ï¿½ï¿½ï¿½Ø£~ï¿½ï¿½ï¿½ï¿½(ï¿½7;ï¿½ï¿½Bï¿½ï¿½hc
-xatï¿½[)ï¿½<ï¿½uï¿½8Ë±r	Pï¿½Èºï¿½ï¿½Dï¿½ ï¿½ï¿½4ï¿½ï¿½*U_ï¿½ï¿½t PKCS#8~r java.security.KeyRep$Type          xr java.lang.Enum          xpt PRIVATE
\ No newline at end of file
Index: Sara/private/privateKey.key
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Sara/private/privateKey.key b/Sara/private/privateKey.key
deleted file mode 100644
--- a/Sara/private/privateKey.key	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ /dev/null	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
@@ -1,15 +0,0 @@
-ï¿½ï¿½ sr java.security.KeyRepï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½C L 	algorithmt Ljava/lang/String;[ encodedt [BL formatq ~ L typet Ljava/security/KeyRep$Type;xpt RSAur [Bï¿½ï¿½ï¿½Tï¿½  xp  ï¿½0ï¿½ï¿½ 0
-	*ï¿½Hï¿½ï¿½
- ï¿½ï¿½0ï¿½ï¿½ ï¿½ ï¿½cï¿½Vï¿½Nï¿½{Xï¿½ï¿½9Pï¿½J=8"cHï¿½ï¿½ï¿½U~ï¿½ï¿½ï¿½~ßŠï¿½ï¿½uï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½jSï¿½&ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½&*aï¿½gï¿½oï¿½qï¿½ï¿½7ï¿½ï¿½Z*ï¿½2ï¿½ï¿½ï¿½Rï¿½B	ï¿½Mï¿½Bï¿½A
-ï¿½ hZ Vï¿½ï¿½<2#leL?ï¿½ï¿½H%ï¿½ï¿½ï¿½9!UQï¿½ï¿½Ù¬0`|WH`ï¿½ï¿½ï¿½Fï¿½U9
-ï¿½	ï¿½.ï¿½EMWï¿½hï¿½ï¿½:ACï¿½}ï¿½paï¿½(ï¿½QfBï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½-ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½g-ï¿½@i&E_ï¿½qï¿½ï¿½ßï¿½ï¿½$ï¿½ 4Pï¿½ï¿½Ø‰ï¿½ï¿½ï¿½ï¿½Aï¿½uï¿½ï¿½3ï¿½ï¿½'ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½ej+ï¿½É¡xVï¿½ï¿½ï¿½y ï¿½ 
-ï¿½ï¿½<ï¿½ï¿½ï¿½[)Ñ”1c~ï¿½ï¿½ï¿½_ï¿½×”ï¿½E^Ô±ï¿½ï¿½Í‰Sï¿½ï¿½*Iï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½C:hï¿½Q{mï¿½ï¿½ï¿½~ï¿½<ï¿½0M(>ï¿½jGP>RÄª+ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½(i8Mï¿½ï¿½_ï¿½"ï¿½ï¿½gï¿½ï¿½ï¿½.<ï¿½Xqï¿½u[ï¿½F,ï¿½ï¿½ï¿½I-ï¿½ï¿½ï¿½+ï¿½>ï¿½Qï¿½Eï¿½Æ‹[ï¿½ï¿½ ï¿½vF ï¿½`ï¿½Å²yï¿½_*)ï¿½ï¿½ï¿½xS#*Â ï¿½ï¿½ï¿½Kï¿½x!;ï¿½ï¿½Vï¿½ï¿½"ï¿½&e2ï¿½0ï¿½Y|Vï¿½ï¿½eï¿½Íï¿½ï¿½Bï¿½gï¿½!Eï¿½.ï¿½Kï¿½+0ï¿½ï¿½ï¿½!Nï¿½ï¿½ï¿½{ï¿½1ßœï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½;È‡ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ oï¿½ï¿½]ï¿½ï¿½ï¿½^ï¿½<&ï¿½ï¿½ï¿½Ôï¿½Eï¿½<&ï¿½
-ï¿½ï¿½ï¿½]wï¿½Rï¿½ï¿½tï¿½@dï¿½nï¿½ï¿½ï¿½'Xï¿½ï¿½ï¿½aï¿½ï¿½'vnï¿½ï¿½Mpï¿½ï¿½ï¿½htï¿½ï¿½Pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½Eï¿½Uï¿½PŞ«%ï¿½ï¿½lï¿½;ï¿½ï¿½ï¿½Uï¿½uï¿½`Ãï¿½J={ï¿½#ï¿½ï¿½ï¿½ ï¿½vï¿½ï¿½
-7ï¿½ï¿½5ï¿½ï¿½eï¿½ï¿½Dï¿½ï¿½>É–
-ï¿½ß†ï¿½aï¿½yï¿½	ï¿½ï¿½ -]hï¿½4oGï¿½ï¿½ï¿½}^'
-ï¿½yï¿½ï¿½Ç“ï¿½]ï¿½ï¿½ç‚©(ï¿½ï¿½68FRDï¿½ï¿½ï¿½uï¿½ï¿½UKï¿½ï¿½yï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½fï¿½z/
-ï¿½
-ï¿½Yaï¿½ï¿½ Jï¿½t^ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½9/Gï¿½o5ï¿½ñ½ï¿½ï¿½{/ï¿½ï¿½ï¿½ï¿½_"ï¿½ï¿½ï¿½ï¿½(6~ï¿½ï¿½ï¿½$Åˆï¿½<ï¿½ï¿½txï¿½ï¿½Iï¿½ï¿½ï¿½'D1~ï¿½WQï¿½ï¿½ï¿½ï¿½ï¿½huï¿½Ïˆ\ï¿½'B6ï¿½5ï¿½ï¿½}ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½.?ï¿½ï¿½ï¿½'ï¿½ï¿½Ã ï¿½/ï¿½ï¿½ï¿½>
-ï¿½=ï¿½FX79ï¿½$ï¿½ï¿½ï¿½&ï¿½Jï¿½nï¿½ï¿½ï¿½ï¿½BvCï¿½Lï¿½|ï¿½Uï¿½'ï¿½}nu(ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wzFï¿½ï¿½ï¿½0ï¿½ï¿½sï¿½Rï¿½İœJgï¿½ï¿½ï¿½Ú’Eï¿½10pï¿½;@ï¿½?ï¿½ï¿½Eï¿½,<ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½xï¿½w
-Pï¿½ï¿½1ï¿½ï¿½ ï¿½Eï¿½ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½zxï¿½ï¿½qwqï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½ï¿½ï¿½Qï¿½(ï¿½Vï¿½Ç¾ï¿½}ï¿½å©¼Mï¿½ï¿½ï¿½wï¿½ï¿½ï¿½
-ï¿½ï¿½sK9ï¿½ï¿½ï¿½ï¿½ï¿½"Kx+ï¿½pï¿½ï¿½ï¿½Pï¿½	ï¿½Nï¿½ï¿½ï¿½fTï¿½sNUT9Éƒï¿½ï¿½[ï¿½ ~ìŠï¿½İ”ï¿½ï¿½Iï¿½ï¿½ï¿½İŠï¿½ï¿½ï¿½ï¿½ï¿½^=ï¿½;ï¿½ï¿½0ï¿½t PKCS#8~r java.security.KeyRep$Type          xr java.lang.Enum          xpt PRIVATE
\ No newline at end of file
Index: src/main/java/DES3.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/DES3.java b/src/main/java/DES3.java
new file mode 100644
--- /dev/null	(date 1683563461722)
+++ b/src/main/java/DES3.java	(date 1683563461722)
@@ -0,0 +1,23 @@
+import javax.crypto.Cipher;
+import javax.crypto.spec.SecretKeySpec;
+import java.util.Arrays;
+
+public class DES3 {
+    //Ã‰ SUPOST SER 3DES MAS NÃƒO ME DEIXA CHAMAR 3DES
+    public static byte[] encrypt(byte[] message, byte[] secretKey) throws Exception {
+        byte[] secretKeyPadded = Arrays.copyOf(secretKey, 24); // 3DES key size is 24 bytes
+        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKeyPadded, "DESede");
+        Cipher cipher = Cipher.getInstance("DESede/ECB/PKCS5Padding");
+        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
+        return cipher.doFinal(message);
+    }
+
+    public static byte[] decrypt(byte[] message, byte[] secretKey) throws Exception {
+        byte[] secretKeyPadded = Arrays.copyOf(secretKey, 24); // 3DES key size is 24 bytes
+        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKeyPadded, "DESede");
+        Cipher cipher = Cipher.getInstance("DESede/ECB/PKCS5Padding");
+        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
+        return cipher.doFinal(message);
+    }
+
+}
Index: Server_G11/private/privateKey.key
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>ï¿½ï¿½\u0000\u0005sr\u0000\u0014java.security.KeyRepï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½C\u0002\u0000\u0004L\u0000\talgorithmt\u0000\u0012Ljava/lang/String;[\u0000\u0007encodedt\u0000\u0002[BL\u0000\u0006formatq\u0000~\u0000\u0001L\u0000\u0004typet\u0000\u001BLjava/security/KeyRep$Type;xpt\u0000\u0003RSAur\u0000\u0002[Bï¿½ï¿½\u0017ï¿½\u0006\bTï¿½\u0002\u0000\u0000xp\u0000\u0000\u0004ï¿½0ï¿½\u0004ï¿½\u0002\u0001\u00000\r\u0006\t*ï¿½Hï¿½ï¿½\r\u0001\u0001\u0001\u0005\u0000\u0004ï¿½\u0004ï¿½0ï¿½\u0004ï¿½\u0002\u0001\u0000\u0002ï¿½\u0001\u0001\u0000ï¿½\u0000ï¿½ï¿½ï¿½\"ï¿½ï¿½ï¿½\u0000ï¿½A[\u0000ï¿½wGv\u0018ï¿½6\u001Aï¿½ï¿½)ï¿½Æ»\"d:ï¿½\u001385ï¿½ï¿½\u001Bï¿½\nï¿½\fY*\u0001ï¿½/qï¿½\u001E\u0000.ï¿½/ï¿½eï¿½ï¿½3ï¿½ï¿½ï¿½I\u001Ax\u0002ï¿½ï¿½\u001E\"ï¿½Hï¿½\u0017.#'ï¿½GB\u0001ï¿½Icï¿½\u001Aï¿½vW50ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½Æ«ï¿½ï¿½\u000Eï¿½;\u001Eï¿½)\u0016dï¿½\u0007Ø–ï¿½3ï¿½]ï¿½Ï–ï¿½ï¿½ï¿½~xoï¿½ï¿½taï¿½ï¿½%ï¿½~ MÄ‘Rï¿½ï¿½arpbï¿½ï¿½ï¿½ï¿½){İ·ï¿½ï¿½ï¿½Mï¿½ï¿½\\ï¿½ï¿½ï¿½ddI9{\u0004blï¿½~ï¿½ï¿½\u0007\u0000ï¿½)^aï¿½\\ï¿½Plï¿½Aï¿½ï¿½Aï¿½ï¿½\u0018ï¿½Bï¿½#^ï¿½OÚ­ï¿½\u001B\u0014\u007FÏ…J.V(\f\u001DO,iï¿½eï¿½ï¿½Qï¿½0ï¿½ï¿½Û¤ï¿½ï¿½w\u0010Dï¿½>Vï¿½ï¿½\u001Cd4lï¿½\u0014ï¿½ï¿½!\u0002\u0003\u0001\u0000\u0001\u0002ï¿½\u0001\u0000LÖ¨ï¿½\u000Bï¿½Yjï¿½\u0001\u001C^ï¿½+\u001Eï¿½ï¿½ï¿½ï¿½\u001Cï¿½sL\u001Eqï¿½_o2\u0004&ï¿½ï¿½gï¿½U4ï¿½,nï¿½:r&3\u0003qï¿½ï¿½ï¿½GVï¿½ï¿½\u0000-!ï¿½Hï¿½ï¿½Lï¿½\u0004`lï¿½Zï¿½Ñ‰ï¿½^ï¿½Ø°ï¿½\u0014ï¿½ï¿½&ï¿½ï¿½<Çï¿½8ï¿½*\u0007ï¿½#ï¿½\"5\u000Eo\u0018ï¿½;4<\u0018\tmï¿½'TX6\u0018Ç™ï¿½ï¿½ï¿½ï¿½\u0017w\u0003C+ï¿½ï¿½ï¿½ï¿½ï¿½`4ï¿½ï¿½ï¿½\u001Bï¿½ï¿½ï¿½\u0006ï¿½\u007F\u001Fï¿½ï¿½8ï¿½ï¿½X\u0015{ï¿½ï¿½\u001Fï¿½ï¿½Û¹ï¿½ï¿½ï¿½ï¿½ï¿½*0ï¿½Å©ï¿½lÒ¨\u001Eï¿½ï¿½ï¿½iï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½8ï¿½\u001Dï¿½-ï¿½ï¿½*ï¿½aï¿½RB=ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½\u0000ï¿½qï¿½%ï¿½ï¿½ï¿½ï¿½Lï¿½fï¿½\tyï¿½ï¿½Aï¿½Ç½ï¿½0ï¿½ï¿½\u001E\u001Cï¿½uï¿½ï¿½j:#ï¿½Wï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½uï¿½\\;\u0002ï¿½ï¿½\u0000Í‚ï¿½~ï¿½cXï¿½\u0006-ï¿½\u001Cï¿½fï¿½ï¿½-ï¿½'Fï¿½ï¿½ï¿½ï¿½ï¿½A\u0001;kï¿½=Ä’vï¿½wJVGzï¿½Cï¿½\u0013fï¿½Q)s\u001F5ï¿½\u0017\u0002ï¿½vxb\tRkKï¿½u*ï¿½\u001B\u0002\u0013ï¿½JFiï¿½ï¿½ï¿½Mï¿½uï¿½ ~ï¿½ï¿½&ï¿½ï¿½\u001DÅ»ï¿½ï¿½ï¿½ï¿½d2dï¿½ï¿½\fz\"ï¿½ï¿½\u0012ï¿½ï¿½\n\u0014'ï¿½\u001Eï¿½Tï¿½zï¿½\u007Fï¿½0[ï¿½c~ï¿½s\u0002ï¿½ï¿½\u0000ï¿½ÍSï¿½7ï¿½ï¿½F.ï¿½!ï¿½ï¿½ï¿½!ï¿½\rï¿½bï¿½Qï¿½K1iï¿½2ï¿½2ï¿½G\u0019l`ï¿½ï¿½ï¿½ï¿½ï¿½Ø³ï¿½\u0018ï¿½ï¿½\u0006R~Qï¿½\u0017ï¿½ï¿½\nI-ï¿½ï¿½jï¿½Í¼xï¿½ï¿½%ï¿½@ï¿½?P9ï¿½aï¿½kï¿½wï¿½XQâ‰£ï¿½->I.ï¿½ï¿½ï¿½j>ï¿½ï¿½\u001Eï¿½\u00029Äï¿½D?sn\u0007\u0001\u0006ï¿½ï¿½ï¿½^ï¿½57ï¿½ï¿½ï¿½[N]ï¿½ï¿½\u001B\u0002ï¿½ï¿½\u0000ï¿½\u0002\u0004ï¿½E5Dï¿½Nï¿½W]F\u0007h*ï¿½q?ï¿½\u001BUnï¿½ï¿½M}ï¿½ï¿½@ï¿½ï¿½F\u0016ï¿½\r\u0007ï¿½ï¿½ï¿½*ï¿½Zï¿½3ï¿½[\fï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½XÃ64lï¿½ï¿½X\u0011ï¿½Öš\u0003ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½Mbï¿½ï¿½ï¿½ï¿½RLz\f%X\u0004ï¿½ï¿½ï¿½\u000Fï¿½\n;Aï¿½:ï¿½ï¿½AjVM\u0005ï¿½6ï¿½\u0003%vï¿½eï¿½0ï¿½\u0000ï¿½ï¿½\u0013ï¿½\u0011ï¿½ï¿½ï¿½\u0002ï¿½ï¿½iï¿½\u0001\u000BY3T`]Xh5ï¿½ï¿½)\u0010!\\ï¿½ï¿½ï¿½ï¿½ï¿½\u001Fï¿½ï¿½Cï¿½rï¿½\u0016Iï¿½rï¿½aSï¿½Hï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½\u0018HXï¿½ï¿½Eï¿½ï¿½hï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½\u0003\u001A:Tï¿½8Ö¸fï¿½Wï¿½ï¿½ï¿½ï¿½H\u0003ï¿½1-ï¿½ï¿½ï¿½=ï¿½Nï¿½Ï¸ï¿½t\u0003ï¿½Ù‡\u07B7=ï¿½Pï¿½)ï¿½ï¿½<ï¿½,9ï¿½ï¿½(\u00195ï¿½RFU\u0019ï¿½C\u001B\u0002ï¿½ï¿½|mï¿½:ï¿½\u001F4ï¿½Qï¿½Æ™ï¿½ï¿½QG<\rï¿½-e\u001Dtv\"6ï¿½ï¿½!\\ï¿½ï¿½Qï¿½Xrï¿½;ï¿½ï¿½zï¿½Vqï¿½ï¿½r\u0003ï¿½ï¿½ï¿½#<ï¿½\u0016ï¿½\u001Aï¿½n\\%ï¿½Tv}ï¿½ï¿½!fï¿½\u00180ï¿½g\u0017ï¿½ï¿½ï¿½Hï¿½\u001EwŞï¿½ï¿½HTï¿½`ï¿½rï¿½0Fï¿½ï¿½Oï¿½ï¿½ï¿½m\u001Bï¿½6ï¿½ï¿½ï¿½+0\u007F(}\u0002ï¿½ï¿½\u001E/ï¿½Xï¿½ï¿½ï¿½Äƒï¿½t\u0000\u0006PKCS#8~r\u0000\u0019java.security.KeyRep$Type\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012\u0000\u0000xr\u0000\u000Ejava.lang.Enum\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012\u0000\u0000xpt\u0000\u0007PRIVATE
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server_G11/private/privateKey.key b/Server_G11/private/privateKey.key
--- a/Server_G11/private/privateKey.key	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ b/Server_G11/private/privateKey.key	(date 1683563464903)
@@ -1,10 +1,11 @@
 ï¿½ï¿½ sr java.security.KeyRepï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½C L 	algorithmt Ljava/lang/String;[ encodedt [BL formatq ~ L typet Ljava/security/KeyRep$Type;xpt RSAur [Bï¿½ï¿½ï¿½Tï¿½  xp  ï¿½0ï¿½ï¿½ 0
 	*ï¿½Hï¿½ï¿½
- ï¿½ï¿½0ï¿½ï¿½ ï¿½ ï¿½ ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ ï¿½A[ ï¿½wGvï¿½6ï¿½ï¿½)ï¿½Æ»"d:ï¿½85ï¿½ï¿½ï¿½
-ï¿½Y*ï¿½/qï¿½ .ï¿½/ï¿½eï¿½ï¿½3ï¿½ï¿½ï¿½Ixï¿½ï¿½"ï¿½Hï¿½.#'ï¿½GBï¿½Icï¿½ï¿½vW50ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½;ï¿½)dï¿½Ø–ï¿½3ï¿½]ï¿½Ï–ï¿½ï¿½ï¿½~xoï¿½ï¿½taï¿½ï¿½%ï¿½~ MÄ‘Rï¿½ï¿½arpbï¿½ï¿½ï¿½ï¿½){İ·ï¿½ï¿½ï¿½Mï¿½ï¿½\ï¿½ï¿½ï¿½ddI9{blï¿½~ï¿½ï¿½ ï¿½)^aï¿½\ï¿½Plï¿½Aï¿½ï¿½Aï¿½ï¿½ï¿½Bï¿½#^ï¿½OÚ­ï¿½Ï…J.V(O,iï¿½eï¿½ï¿½Qï¿½0ï¿½ï¿½Û¤ï¿½ï¿½wDï¿½>Vï¿½ï¿½d4lï¿½ï¿½ï¿½! ï¿½ LÖ¨ï¿½ï¿½Yjï¿½^ï¿½+ï¿½ï¿½ï¿½ï¿½ï¿½sLqï¿½_o2&ï¿½ï¿½gï¿½U4ï¿½,nï¿½:r&3qï¿½ï¿½ï¿½GVï¿½ï¿½ -!ï¿½Hï¿½ï¿½Lï¿½`lï¿½Zï¿½Ñ‰ï¿½^ï¿½Ø°ï¿½ï¿½ï¿½&ï¿½ï¿½<Çï¿½8ï¿½*ï¿½#ï¿½"5oï¿½;4<	mï¿½'TX6Ç™ï¿½ï¿½ï¿½ï¿½wC+ï¿½ï¿½ï¿½ï¿½ï¿½`4ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½X{ï¿½ï¿½ï¿½ï¿½Û¹ï¿½ï¿½ï¿½ï¿½ï¿½*0ï¿½Å©ï¿½lÒ¨ï¿½ï¿½ï¿½iï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½-ï¿½ï¿½*ï¿½aï¿½RB=ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½qï¿½%ï¿½ï¿½ï¿½ï¿½Lï¿½fï¿½	yï¿½ï¿½Aï¿½Ç½ï¿½0ï¿½ï¿½ï¿½uï¿½ï¿½j:#ï¿½Wï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½uï¿½\;ï¿½ï¿½ Í‚ï¿½~ï¿½cXï¿½-ï¿½ï¿½fï¿½ï¿½-ï¿½'Fï¿½ï¿½ï¿½ï¿½ï¿½A;kï¿½=Ä’vï¿½wJVGzï¿½Cï¿½fï¿½Q)s5ï¿½ï¿½vxb	RkKï¿½u*ï¿½ï¿½JFiï¿½ï¿½ï¿½Mï¿½uï¿½ ~ï¿½ï¿½&ï¿½ï¿½Å»ï¿½ï¿½ï¿½ï¿½d2dï¿½ï¿½z"ï¿½ï¿½ï¿½ï¿½
-'ï¿½ï¿½Tï¿½zï¿½ï¿½0[ï¿½c~ï¿½sï¿½ï¿½ ï¿½ÍSï¿½7ï¿½ï¿½F.ï¿½!ï¿½ï¿½ï¿½!ï¿½
-ï¿½bï¿½Qï¿½K1iï¿½2ï¿½2ï¿½Gl`ï¿½ï¿½ï¿½ï¿½ï¿½Ø³ï¿½ï¿½ï¿½R~Qï¿½ï¿½ï¿½
-I-ï¿½ï¿½jï¿½Í¼xï¿½ï¿½%ï¿½@ï¿½?P9ï¿½aï¿½kï¿½wï¿½XQâ‰£ï¿½->I.ï¿½ï¿½ï¿½j>ï¿½ï¿½ï¿½9Äï¿½D?snï¿½ï¿½ï¿½^ï¿½57ï¿½ï¿½ï¿½[N]ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½E5Dï¿½Nï¿½W]Fh*ï¿½q?ï¿½Unï¿½ï¿½M}ï¿½ï¿½@ï¿½ï¿½Fï¿½
-ï¿½ï¿½ï¿½*ï¿½Zï¿½3ï¿½[ï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½XÃ64lï¿½ï¿½Xï¿½Öšï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Mbï¿½ï¿½ï¿½ï¿½RLz%Xï¿½ï¿½ï¿½ï¿½
-;Aï¿½:ï¿½ï¿½AjVMï¿½6ï¿½%vï¿½eï¿½0ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iï¿½Y3T`]Xh5ï¿½ï¿½)!\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½rï¿½Iï¿½rï¿½aSï¿½Hï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½HXï¿½ï¿½Eï¿½ï¿½hï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½:Tï¿½8Ö¸fï¿½Wï¿½ï¿½ï¿½ï¿½Hï¿½1-ï¿½ï¿½ï¿½=ï¿½Nï¿½Ï¸ï¿½tï¿½Ù‡Ş·=ï¿½Pï¿½)ï¿½ï¿½<ï¿½,9ï¿½ï¿½(5ï¿½RFUï¿½Cï¿½ï¿½|mï¿½:ï¿½4ï¿½Qï¿½Æ™ï¿½ï¿½QG<
-ï¿½-etv"6ï¿½ï¿½!\ï¿½ï¿½Qï¿½Xrï¿½;ï¿½ï¿½zï¿½Vqï¿½ï¿½rï¿½ï¿½ï¿½#<ï¿½ï¿½ï¿½n\%ï¿½Tv}ï¿½ï¿½!fï¿½0ï¿½gï¿½ï¿½ï¿½Hï¿½wŞï¿½ï¿½HTï¿½`ï¿½rï¿½0Fï¿½ï¿½Oï¿½ï¿½ï¿½mï¿½6ï¿½ï¿½ï¿½+0(}ï¿½ï¿½/ï¿½Xï¿½ï¿½ï¿½Äƒï¿½t PKCS#8~r java.security.KeyRep$Type          xr java.lang.Enum          xpt PRIVATE
\ No newline at end of file
+ ï¿½ï¿½0ï¿½ï¿½ ï¿½ ï¿½ZVï¿½ePĞ¿ï¿½wï¿½ï¿½ï¿½D/ï¿½Lï¿½+ï¿½`"ï¿½l>ï¿½ï¿½×”ï¿½&;ï¿½ï¿½ë¸½js+ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½|hb+p>ï¿½fï¿½yQï¿½ï¿½Ï“^ï¿½<ï¿½wï¿½,
+$.Sï¿½ï¿½Z'ï¿½hï¿½ï¿½pï¿½cQypKï¿½n,|}ï¿½y6DlÇ´ï¿½ï¿½Xï¿½ï¿½;ï¿½ï¿½<wï¿½ï¿½ï¿½ï¿½ï¿½ÅœG)ï¿½ï¿½'nJhï¿½|@$gŞ³ï¿½ï¿½ï¿½%ï¿½ï¿½ï¿½o ï¿½ï¿½?ï¿½ï¿½%mï¿½aï¿½ï¿½xaWï¿½Bljï¿½ï¿½-ï¿½dï¿½ï¿½ï¿½4ìª
+ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½3HGï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½Mï¿½ÄŠ0;ï¿½ÇŒï¿½Tï¿½ï¿½H;ï¿½çµï¿½ï¿½^ï¿½ï¿½ï¿½rÍ³ï¿½ï¿½ï¿½{ä±ï¿½ ï¿½  ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½q	ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½4/CVï¿½ï¿½ï¿½Iï¿½]
+Oï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½# ï¿½X2ï¿½ï¿½wï¿½ï¿½b#ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½eï¿½n	bï¿½ Ş’ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½vÙ¦ï¿½ï¿½y"h_ï¿½ï¿½rï¿½ï¿½_ï¿½@ï¿½(ï¿½rï¿½Jï¿½ï¿½^Bï¿½Nï¿½+ï¿½_\3ï¿½ï¿½!Ü¿1Aï¿½5ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ã©ï¿½~ï¿½ï¿½æ”¹7,ï¿½Ëï¿½ï¿½ï¿½h7ï¿½ï¿½ï¿½ï¿½Ò¯/wï¿½
+4HeUï¿½Dï¿½ï¿½ï¿½M4ï¿½cï¿½è­–c5ï¿½^ï¿½ï¿½3ï¿½wU mwï¿½ï¿½ï¿½ï¿½ï¿½kUE0<.ï¿½ï¿½iï¿½#ï¿½ï¿½Lï¿½Lï¿½ï¿½ï¿½ï¿½$Öï¿½@ï¿½ï¿½	Xï¿½Qï¿½ï¿½ ×§ï¿½&XbPï¿½ï¿½:j Asï¿½ï¿½ï¿½ï¿½w1
+*ï¿½ï¿½Kï¿½ï¿½Tï¿½7lï¿½4ï¿½o&ï¿½`ï¿½4
+ï¿½ï¿½7#kï¿½à¶œï¿½7{ï¿½ï¿½rrï¿½=ï¿½yï¿½Ü¶ĞŸ[ï¿½lWï¿½ï¿½:lï¿½=ï¿½1{ï¿½ï¿½ï¿½ï¿½ï¿½
+%ï¿½ï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ttï¿½ Fï¿½|wï¿½ï¿½ï¿½Fï¿½Bï¿½ï¿½"ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½/!ï¿½lxï¿½ï¿½ï¿½ï¿½^ï¿½ #ï¿½ ï¿½ï¿½Iï¿½oÉ‘-Pï¿½ï¿½ï¿½Rï¿½ï¿½ï¿½D?ï¿½ï¿½XkBï¿½Äªï¿½ï¿½aï¿½İ­ï¿½ï¿½6|ï¿½t*ï¿½4ï¿½Æ¼ï¿½ï¿½aï¿½ï¿½SJ7ï¿½;ï¿½vï¿½×·Gï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½@ï¿½Oï¿½ï¿½B"ï¿½ï¿½ï¿½ï¿½ï¿½9ï¿½ï¿½&ï¿½ï¿½ï¿½uï¿½ï¿½xï¿½<ï¿½ï¿½ï¿½;Hï¿½~|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Fï¿½Cï¿½ANBï¿½ï¿½ï¿½H"ï¿½ï¿½cï¿½uï¿½vï¿½-Ğ¡ï¿½?ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½cï¿½ï¿½ï¿½	ï¿½ï¿½Í§ï¿½ï¿½JRï¿½ï¿½ï¿½ï¿½.ï¿½Yï¿½Zwï¿½ï¿½
+~ï¿½ï¿½ï¿½k& ï¿½0ï¿½ï¿½ï¿½*ï¿½i.ï¿½Ô¥(ï¿½jï¿½IMQï¿½#ï¿½/\(;%bAï¿½ï¿½?52KG&Ì°/ZMï¿½ï¿½Oï¿½w&,zï¿½tï¿½[ï¿½ï¿½ï¿½U|ï¿½Sï¿½ï¿½ï¿½7ï¿½1fGï¿½ï¿½ï¿½)Jî¦‰ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½AUjï¿½vOHÙ¸ï¿½!ï¿½ï¿½ï¿½-Bï¿½vï¿½ï¿½ï¿½ï¿½Aï¿½d/ï¿½ï¿½8(ï¿½{ï¿½J>ï¿½rx ï¿½ï¿½>kï¿½J5ï¿½ï¿½ï¿½Kï¿½]7ï¿½ï¿½ï¿½ ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½qï¿½Bi*ï¿½5eï¿½TVï¿½Qï¿½ï¿½Ç£3ÙŠSc-oR;ï¿½ï¿½ï¿½ï¿½/#ï¿½_ï¿½Fï¿½ï¿½]Yï¿½yï¿½Ë¦Åšï¿½ï¿½ï¿½ï¿½Dï¿½Mï¿½#3XXï¿½Kï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½tZï¿½ï¿½ï¿½ï¿½ayï¿½ï¿½b;amï¿½Ö…ï¿½ï¿½ï¿½Ø³*ï¿½tHï¿½ï¿½k@!ï¿½Eï¿½t PKCS#8~r java.security.KeyRep$Type          xr java.lang.Enum          xpt PRIVATE
\ No newline at end of file
Index: server/Registry/registry.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Sara : 1\r\nStere : 1\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server/Registry/registry.txt b/server/Registry/registry.txt
--- a/server/Registry/registry.txt	(revision 6a82080d1e2bd7670f70553fcd8edc262ee65f0d)
+++ b/server/Registry/registry.txt	(date 1683563497544)
@@ -1,2 +1,1 @@
 Sara : 1
-Stere : 1
